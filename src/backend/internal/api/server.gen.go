// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	CookieAuthScopes = "cookieAuth.Scopes"
)

// Defines values for GitHubAppInstallationAccountType.
const (
	GitHubAppInstallationAccountTypeOrganization GitHubAppInstallationAccountType = "organization"
	GitHubAppInstallationAccountTypeUser         GitHubAppInstallationAccountType = "user"
)

// Defines values for OrganizationAccessStatus.
const (
	OrganizationAccessStatusAccessible OrganizationAccessStatus = "accessible"
	OrganizationAccessStatusPending    OrganizationAccessStatus = "pending"
	OrganizationAccessStatusRestricted OrganizationAccessStatus = "restricted"
)

// Defines values for OwnershipFilterParam.
const (
	OwnershipFilterParamAll          OwnershipFilterParam = "all"
	OwnershipFilterParamMine         OwnershipFilterParam = "mine"
	OwnershipFilterParamOrganization OwnershipFilterParam = "organization"
	OwnershipFilterParamOthers       OwnershipFilterParam = "others"
)

// Defines values for PlanTier.
const (
	Enterprise PlanTier = "enterprise"
	Free       PlanTier = "free"
	Pro        PlanTier = "pro"
	ProPlus    PlanTier = "pro_plus"
)

// Defines values for SortByParam.
const (
	Name   SortByParam = "name"
	Recent SortByParam = "recent"
	Tests  SortByParam = "tests"
)

// Defines values for SortOrderParam.
const (
	Asc  SortOrderParam = "asc"
	Desc SortOrderParam = "desc"
)

// Defines values for SpecGenerationStatusEnum.
const (
	SpecGenerationStatusEnumCompleted SpecGenerationStatusEnum = "completed"
	SpecGenerationStatusEnumFailed    SpecGenerationStatusEnum = "failed"
	SpecGenerationStatusEnumNotFound  SpecGenerationStatusEnum = "not_found"
	SpecGenerationStatusEnumPending   SpecGenerationStatusEnum = "pending"
	SpecGenerationStatusEnumRunning   SpecGenerationStatusEnum = "running"
)

// Defines values for SpecLanguage.
const (
	Arabic     SpecLanguage = "Arabic"
	Chinese    SpecLanguage = "Chinese"
	Czech      SpecLanguage = "Czech"
	Danish     SpecLanguage = "Danish"
	Dutch      SpecLanguage = "Dutch"
	English    SpecLanguage = "English"
	Finnish    SpecLanguage = "Finnish"
	French     SpecLanguage = "French"
	German     SpecLanguage = "German"
	Greek      SpecLanguage = "Greek"
	Hindi      SpecLanguage = "Hindi"
	Indonesian SpecLanguage = "Indonesian"
	Italian    SpecLanguage = "Italian"
	Japanese   SpecLanguage = "Japanese"
	Korean     SpecLanguage = "Korean"
	Polish     SpecLanguage = "Polish"
	Portuguese SpecLanguage = "Portuguese"
	Russian    SpecLanguage = "Russian"
	Spanish    SpecLanguage = "Spanish"
	Swedish    SpecLanguage = "Swedish"
	Thai       SpecLanguage = "Thai"
	Turkish    SpecLanguage = "Turkish"
	Ukrainian  SpecLanguage = "Ukrainian"
	Vietnamese SpecLanguage = "Vietnamese"
)

// Defines values for TestStatus.
const (
	Active  TestStatus = "active"
	Focused TestStatus = "focused"
	Skipped TestStatus = "skipped"
	Todo    TestStatus = "todo"
	Xfail   TestStatus = "xfail"
)

// Defines values for UpdateStatus.
const (
	NewCommits UpdateStatus = "new-commits"
	Unknown    UpdateStatus = "unknown"
	UpToDate   UpdateStatus = "up-to-date"
)

// Defines values for UsageEventType.
const (
	Analysis UsageEventType = "analysis"
	Specview UsageEventType = "specview"
)

// Defines values for ViewFilterParam.
const (
	ViewFilterParamAll       ViewFilterParam = "all"
	ViewFilterParamCommunity ViewFilterParam = "community"
	ViewFilterParamMy        ViewFilterParam = "my"
)

// Defines values for WebhookAccountType.
const (
	Organization WebhookAccountType = "Organization"
	User         WebhookAccountType = "User"
)

// Defines values for GetUserAnalyzedRepositoriesParamsOwnership.
const (
	GetUserAnalyzedRepositoriesParamsOwnershipAll          GetUserAnalyzedRepositoriesParamsOwnership = "all"
	GetUserAnalyzedRepositoriesParamsOwnershipMine         GetUserAnalyzedRepositoriesParamsOwnership = "mine"
	GetUserAnalyzedRepositoriesParamsOwnershipOrganization GetUserAnalyzedRepositoriesParamsOwnership = "organization"
)

// AddAnalyzedRepositoryRequest defines model for AddAnalyzedRepositoryRequest.
type AddAnalyzedRepositoryRequest struct {
	// Owner GitHub repository owner
	Owner string `json:"owner"`

	// Repo GitHub repository name
	Repo string `json:"repo"`
}

// AddAnalyzedRepositoryResponse defines model for AddAnalyzedRepositoryResponse.
type AddAnalyzedRepositoryResponse struct {
	// AnalysisID Analysis ID added to user's history
	AnalysisID string `json:"analysisId"`

	// UpdatedAt ISO 8601 timestamp when the history was updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// AiSpecSummary defines model for AiSpecSummary.
type AiSpecSummary struct {
	// HasSpec Whether completed AI Spec exists for this repository
	HasSpec bool `json:"hasSpec"`

	// LanguageCount Number of languages with completed specs
	LanguageCount *int `json:"languageCount,omitempty"`

	// LatestGeneratedAt Most recent spec generation timestamp
	LatestGeneratedAt *time.Time `json:"latestGeneratedAt,omitempty"`
}

// AnalysisResponse defines model for AnalysisResponse.
type AnalysisResponse struct {
	union json.RawMessage
}

// AnalysisResult defines model for AnalysisResult.
type AnalysisResult struct {
	// AnalyzedAt ISO 8601 timestamp of analysis completion
	AnalyzedAt time.Time `json:"analyzedAt"`

	// BranchName Branch name that was analyzed
	BranchName *string `json:"branchName,omitempty"`

	// CommitSHA Git commit SHA that was analyzed
	CommitSHA string `json:"commitSha"`

	// CommittedAt ISO 8601 timestamp of the commit
	CommittedAt *time.Time `json:"committedAt,omitempty"`

	// ID Analysis ID (UUID)
	ID openapi_types.UUID `json:"id"`

	// IsInMyHistory Whether this analysis is in the current user's dashboard history
	IsInMyHistory *bool `json:"isInMyHistory,omitempty"`

	// Owner Repository owner
	Owner string `json:"owner"`

	// ParserVersion Parser version used for this analysis (e.g., "v1.5.1 (deacdda)")
	ParserVersion *string `json:"parserVersion,omitempty"`

	// Repo Repository name
	Repo    string      `json:"repo"`
	Suites  []TestSuite `json:"suites"`
	Summary Summary     `json:"summary"`
}

// AnalysisSummary defines model for AnalysisSummary.
type AnalysisSummary struct {
	// AnalyzedAt ISO 8601 timestamp when analysis was completed
	AnalyzedAt time.Time `json:"analyzedAt"`

	// Change Change in test count compared to previous analysis
	Change int `json:"change"`

	// CommitSHA Git commit SHA that was analyzed
	CommitSHA string `json:"commitSha"`

	// TestCount Total number of tests in the latest analysis
	TestCount   int                `json:"testCount"`
	TestSummary *TestStatusSummary `json:"testSummary,omitempty"`
}

// AnalyzingResponse defines model for AnalyzingResponse.
type AnalyzingResponse struct {
	// StartedAt When the analysis job started running (ISO 8601)
	StartedAt *time.Time `json:"startedAt,omitempty"`
	Status    string     `json:"status"`
}

// AvailableLanguageInfo defines model for AvailableLanguageInfo.
type AvailableLanguageInfo struct {
	// CreatedAt When this language was last generated
	CreatedAt time.Time `json:"createdAt"`

	// Language Target language for spec document generation (24 languages supported)
	Language SpecLanguage `json:"language"`

	// LatestVersion Latest version number for this language
	LatestVersion int `json:"latestVersion"`
}

// BookmarkResponse defines model for BookmarkResponse.
type BookmarkResponse struct {
	// IsBookmarked Current bookmark status after the operation
	IsBookmarked bool `json:"isBookmarked"`

	// Success Operation success status
	Success bool `json:"success"`
}

// BookmarkedRepositoriesResponse defines model for BookmarkedRepositoriesResponse.
type BookmarkedRepositoriesResponse struct {
	// Data Bookmarked repositories
	Data []RepositoryCard `json:"data"`
}

// CheckQuotaRequest defines model for CheckQuotaRequest.
type CheckQuotaRequest struct {
	// Amount Number of operations to check quota for
	Amount *int `json:"amount,omitempty"`

	// EventType Type of usage event:
	// - specview: SpecView generation
	// - analysis: Repository analysis
	EventType UsageEventType `json:"eventType"`
}

// CheckQuotaResponse defines model for CheckQuotaResponse.
type CheckQuotaResponse struct {
	// IsAllowed Whether the requested operation is allowed
	IsAllowed bool `json:"isAllowed"`

	// Limit Usage limit (null for unlimited/enterprise)
	Limit *int `json:"limit"`

	// ResetAt When the usage period resets
	ResetAt time.Time `json:"resetAt"`

	// Used Current usage count for the event type
	Used int `json:"used"`
}

// CompletedResponse defines model for CompletedResponse.
type CompletedResponse struct {
	Data   AnalysisResult `json:"data"`
	Status string         `json:"status"`
}

// DevLoginRequest defines model for DevLoginRequest.
type DevLoginRequest struct {
	// UserID Optional user ID to login as (uses default test user if not provided)
	UserID *string `json:"userId,omitempty"`

	// Username Optional username for test user (default is "test-user")
	Username *string `json:"username,omitempty"`
}

// DevLoginResponse defines model for DevLoginResponse.
type DevLoginResponse struct {
	Success bool     `json:"success"`
	User    UserInfo `json:"user"`
}

// FailedResponse defines model for FailedResponse.
type FailedResponse struct {
	// Error Error message describing the failure
	Error  string `json:"error"`
	Status string `json:"status"`
}

// Framework Testing framework identifier
type Framework = string

// FrameworkSummary defines model for FrameworkSummary.
type FrameworkSummary struct {
	Active  int `json:"active"`
	Focused int `json:"focused"`

	// Framework Testing framework identifier
	Framework Framework `json:"framework"`
	Skipped   int       `json:"skipped"`
	Todo      int       `json:"todo"`
	Total     int       `json:"total"`
	Xfail     int       `json:"xfail"`
}

// GitHubAppInstallURLResponse defines model for GitHubAppInstallUrlResponse.
type GitHubAppInstallURLResponse struct {
	// InstallURL URL to install the GitHub App
	InstallURL string `json:"installUrl"`
}

// GitHubAppInstallation defines model for GitHubAppInstallation.
type GitHubAppInstallation struct {
	// AccountAvatarURL GitHub account avatar URL
	AccountAvatarURL *string `json:"accountAvatarUrl,omitempty"`

	// AccountID GitHub account ID
	AccountID int64 `json:"accountId"`

	// AccountLogin GitHub account login name
	AccountLogin string `json:"accountLogin"`

	// AccountType Type of GitHub account
	AccountType GitHubAppInstallationAccountType `json:"accountType"`

	// CreatedAt When the installation was created
	CreatedAt time.Time `json:"createdAt"`

	// ID Internal installation record ID
	ID string `json:"id"`

	// InstallationID GitHub installation ID
	InstallationID int64 `json:"installationId"`

	// IsSuspended Whether the installation is suspended
	IsSuspended bool `json:"isSuspended"`
}

// GitHubAppInstallationAccountType Type of GitHub account
type GitHubAppInstallationAccountType string

// GitHubAppInstallationsResponse defines model for GitHubAppInstallationsResponse.
type GitHubAppInstallationsResponse struct {
	// Data List of GitHub App installations
	Data []GitHubAppInstallation `json:"data"`
}

// GitHubOrganization defines model for GitHubOrganization.
type GitHubOrganization struct {
	// AccessStatus Organization repository access status.
	// - accessible: GitHub App installed, can access organization repositories
	// - restricted: No GitHub App installation, cannot access organization repositories
	// - pending: GitHub App installation is suspended
	AccessStatus OrganizationAccessStatus `json:"accessStatus"`

	// AvatarURL Organization avatar URL
	AvatarURL *string `json:"avatarUrl,omitempty"`

	// Description Organization description
	Description *string `json:"description,omitempty"`

	// ID GitHub organization ID
	ID int64 `json:"id"`

	// Login Organization login name
	Login string `json:"login"`
}

// GitHubOrganizationsResponse defines model for GitHubOrganizationsResponse.
type GitHubOrganizationsResponse struct {
	// Data List of GitHub organizations
	Data []GitHubOrganization `json:"data"`
}

// GitHubRepositoriesResponse defines model for GitHubRepositoriesResponse.
type GitHubRepositoriesResponse struct {
	// Data List of GitHub repositories
	Data []GitHubRepository `json:"data"`
}

// GitHubRepository defines model for GitHubRepository.
type GitHubRepository struct {
	// DefaultBranch Default branch name
	DefaultBranch string `json:"defaultBranch"`

	// Description Repository description
	Description *string `json:"description,omitempty"`

	// FullName Full repository name in owner/name format
	FullName string `json:"fullName"`

	// ID GitHub repository ID
	ID int64 `json:"id"`

	// IsPrivate Whether the repository is private
	IsPrivate bool `json:"isPrivate"`

	// Name Repository name
	Name string `json:"name"`

	// Owner Repository owner login
	Owner string `json:"owner"`

	// PushedAt Last push timestamp
	PushedAt *time.Time `json:"pushedAt,omitempty"`
}

// GitHubWebhookPayload GitHub webhook payload. The structure varies by event type.
// This schema represents the common fields; specific event handling uses raw JSON.
type GitHubWebhookPayload struct {
	// Action The action that was performed (e.g., created, deleted, added, removed)
	Action       *string              `json:"action,omitempty"`
	Installation *WebhookInstallation `json:"installation,omitempty"`

	// Repositories Repositories affected by the event (for installation_repositories events)
	Repositories *[]WebhookRepository `json:"repositories,omitempty"`

	// RepositoriesAdded Repositories added (for installation_repositories.added events)
	RepositoriesAdded *[]WebhookRepository `json:"repositories_added,omitempty"`

	// RepositoriesRemoved Repositories removed (for installation_repositories.removed events)
	RepositoriesRemoved *[]WebhookRepository `json:"repositories_removed,omitempty"`
	Sender              *WebhookSender       `json:"sender,omitempty"`
}

// LoginResponse defines model for LoginResponse.
type LoginResponse struct {
	// AuthURL GitHub OAuth authorization URL to redirect user
	AuthURL string `json:"authUrl"`
}

// LogoutResponse defines model for LogoutResponse.
type LogoutResponse struct {
	// Success Logout operation result
	Success bool `json:"success"`
}

// OrganizationAccessStatus Organization repository access status.
// - accessible: GitHub App installed, can access organization repositories
// - restricted: No GitHub App installation, cannot access organization repositories
// - pending: GitHub App installation is suspended
type OrganizationAccessStatus string

// OwnershipFilterParam Filter repositories by ownership type:
// - all: All analyzed repositories (personal and organization)
// - mine: Only repositories owned by the current user
// - organization: Only repositories owned by organizations the user is a member of
// - others: Only repositories owned by other users (not mine, not organization)
type OwnershipFilterParam string

// PaginatedRepositoriesResponse defines model for PaginatedRepositoriesResponse.
type PaginatedRepositoriesResponse struct {
	// Data Repositories in the current page
	Data []RepositoryCard `json:"data"`

	// HasNext Whether more pages are available
	HasNext bool `json:"hasNext"`

	// NextCursor Cursor for fetching the next page (null if no more pages)
	NextCursor *string `json:"nextCursor"`
}

// PlanInfo defines model for PlanInfo.
type PlanInfo struct {
	// AnalysisMonthlyLimit Monthly analysis limit (null for unlimited)
	AnalysisMonthlyLimit *int `json:"analysisMonthlyLimit"`

	// RetentionDays Data retention in days (null for unlimited)
	RetentionDays *int `json:"retentionDays"`

	// SpecviewMonthlyLimit Monthly SpecView limit (null for unlimited)
	SpecviewMonthlyLimit *int `json:"specviewMonthlyLimit"`

	// Tier Subscription plan tier:
	// - free: Free tier with limited quotas
	// - pro: Pro tier with expanded limits
	// - pro_plus: Pro Plus tier with higher limits
	// - enterprise: Enterprise tier with unlimited usage
	Tier PlanTier `json:"tier"`
}

// PlanTier Subscription plan tier:
// - free: Free tier with limited quotas
// - pro: Pro tier with expanded limits
// - pro_plus: Pro Plus tier with higher limits
// - enterprise: Enterprise tier with unlimited usage
type PlanTier string

// PricingPlan defines model for PricingPlan.
type PricingPlan struct {
	// AnalysisMonthlyLimit Monthly analysis limit (null for unlimited)
	AnalysisMonthlyLimit *int `json:"analysisMonthlyLimit"`

	// MonthlyPrice Monthly price in dollars (null for enterprise/custom)
	MonthlyPrice *int `json:"monthlyPrice"`

	// RetentionDays Data retention in days (null for unlimited)
	RetentionDays *int `json:"retentionDays"`

	// SpecviewMonthlyLimit Monthly SpecView limit (null for unlimited)
	SpecviewMonthlyLimit *int `json:"specviewMonthlyLimit"`

	// Tier Subscription plan tier:
	// - free: Free tier with limited quotas
	// - pro: Pro tier with expanded limits
	// - pro_plus: Pro Plus tier with higher limits
	// - enterprise: Enterprise tier with unlimited usage
	Tier PlanTier `json:"tier"`
}

// PricingResponse defines model for PricingResponse.
type PricingResponse struct {
	Data []PricingPlan `json:"data"`
}

// ProblemDetail defines model for ProblemDetail.
type ProblemDetail struct {
	// Detail Human-readable explanation specific to this occurrence
	Detail string `json:"detail"`

	// Instance URI reference identifying the specific occurrence
	Instance  *string        `json:"instance,omitempty"`
	RateLimit *RateLimitInfo `json:"rateLimit,omitempty"`

	// Status HTTP status code
	Status int `json:"status"`

	// Title Human-readable summary
	Title string `json:"title"`

	// Type URI identifying the problem type
	Type *string `json:"type,omitempty"`
}

// QueuedResponse defines model for QueuedResponse.
type QueuedResponse struct {
	Status string `json:"status"`
}

// RateLimitInfo defines model for RateLimitInfo.
type RateLimitInfo struct {
	// Limit Maximum requests allowed per time window
	Limit int `json:"limit"`

	// Remaining Remaining requests in current window
	Remaining int `json:"remaining"`

	// ResetAt Unix timestamp when the rate limit resets
	ResetAt int64 `json:"resetAt"`
}

// RefreshResponse defines model for RefreshResponse.
type RefreshResponse struct {
	// Success Token refresh operation result
	Success bool `json:"success"`
}

// RepositoryCard defines model for RepositoryCard.
type RepositoryCard struct {
	AiSpecSummary *AiSpecSummary `json:"aiSpecSummary,omitempty"`

	// FullName Full repository name in owner/name format
	FullName string `json:"fullName"`

	// ID Repository ID
	ID string `json:"id"`

	// IsAnalyzedByMe Whether the repository was analyzed by the current user
	IsAnalyzedByMe bool `json:"isAnalyzedByMe"`

	// IsBookmarked Whether the repository is bookmarked by the user
	IsBookmarked   bool             `json:"isBookmarked"`
	LatestAnalysis *AnalysisSummary `json:"latestAnalysis,omitempty"`

	// Name Repository name
	Name string `json:"name"`

	// Owner Repository owner (user or organization)
	Owner string `json:"owner"`

	// UpdateStatus Repository update status:
	// - up-to-date: Latest analysis is current with HEAD
	// - new-commits: New commits available since last analysis
	// - unknown: Unable to determine status
	UpdateStatus UpdateStatus `json:"updateStatus"`
}

// RepositoryStatsResponse defines model for RepositoryStatsResponse.
type RepositoryStatsResponse struct {
	// TotalRepositories Total number of analyzed repositories for the user
	TotalRepositories int `json:"totalRepositories"`

	// TotalTests Total number of tests across all repositories
	TotalTests int `json:"totalTests"`
}

// RequestSpecGenerationRequest defines model for RequestSpecGenerationRequest.
type RequestSpecGenerationRequest struct {
	// AnalysisID Analysis ID to generate spec document for
	AnalysisID openapi_types.UUID `json:"analysisId"`

	// IsForceRegenerate Force regeneration even if document exists
	IsForceRegenerate *bool `json:"isForceRegenerate,omitempty"`

	// Language Target language for spec document generation (24 languages supported)
	Language *SpecLanguage `json:"language,omitempty"`
}

// RequestSpecGenerationResponse defines model for RequestSpecGenerationResponse.
type RequestSpecGenerationResponse struct {
	// AnalysisID Analysis ID for tracking
	AnalysisID openapi_types.UUID `json:"analysisId"`

	// Message Optional status message
	Message *string `json:"message,omitempty"`

	// Status Generation status:
	// - pending: Job queued but not started
	// - running: AI generation in progress
	// - completed: Document successfully generated
	// - failed: Generation failed
	// - not_found: No generation request exists
	Status SpecGenerationStatusEnum `json:"status"`
}

// SortByParam Field to sort repositories by:
// - name: Repository name (alphabetical)
// - recent: Analysis timestamp (most recent first)
// - tests: Test count (highest first)
type SortByParam string

// SortOrderParam Sort direction:
// - asc: Ascending order
// - desc: Descending order
// Defaults depend on sortBy (desc for recent/tests, asc for name)
type SortOrderParam string

// SpecBehavior defines model for SpecBehavior.
type SpecBehavior struct {
	// ConvertedDescription AI-converted natural language description
	ConvertedDescription string `json:"convertedDescription"`

	// ID Behavior ID
	ID openapi_types.UUID `json:"id"`

	// OriginalName Original test case name
	OriginalName string `json:"originalName"`

	// SortOrder Display order within feature
	SortOrder  int                     `json:"sortOrder"`
	SourceInfo *SpecBehaviorSourceInfo `json:"sourceInfo,omitempty"`

	// SourceTestCaseID Reference to original test case
	SourceTestCaseID *openapi_types.UUID `json:"sourceTestCaseId,omitempty"`
}

// SpecBehaviorSourceInfo defines model for SpecBehaviorSourceInfo.
type SpecBehaviorSourceInfo struct {
	// FilePath Test file path
	FilePath string `json:"filePath"`

	// Framework Testing framework identifier
	Framework Framework `json:"framework"`

	// LineNumber Line number in the test file
	LineNumber int `json:"lineNumber"`

	// Status Test status indicator:
	// - active: Normal test that will run
	// - focused: Test marked to run exclusively (e.g., it.only)
	// - skipped: Test marked to be skipped (e.g., it.skip)
	// - todo: Placeholder test to be implemented
	// - xfail: Expected to fail (pytest xfail)
	Status TestStatus `json:"status"`
}

// SpecDocument defines model for SpecDocument.
type SpecDocument struct {
	// AnalysisID Associated analysis ID
	AnalysisID openapi_types.UUID `json:"analysisId"`

	// AvailableLanguages List of all available languages for this analysis
	AvailableLanguages *[]AvailableLanguageInfo `json:"availableLanguages,omitempty"`

	// CreatedAt Document creation timestamp
	CreatedAt time.Time `json:"createdAt"`

	// Domains Domain classifications
	Domains []SpecDomain `json:"domains"`

	// ExecutiveSummary AI-generated executive summary of the test suite
	ExecutiveSummary *string `json:"executiveSummary,omitempty"`

	// ID Spec document ID
	ID openapi_types.UUID `json:"id"`

	// Language Target language for spec document generation (24 languages supported)
	Language SpecLanguage `json:"language"`

	// ModelID AI model ID used for generation
	ModelID *string `json:"modelId,omitempty"`

	// Version Document version number (increments on regeneration)
	Version int `json:"version"`
}

// SpecDocumentCompleted defines model for SpecDocumentCompleted.
type SpecDocumentCompleted struct {
	Data   SpecDocument `json:"data"`
	Status string       `json:"status"`
}

// SpecDocumentGenerating defines model for SpecDocumentGenerating.
type SpecDocumentGenerating struct {
	GenerationStatus SpecGenerationStatus `json:"generationStatus"`
	Status           string               `json:"status"`
}

// SpecDocumentResponse defines model for SpecDocumentResponse.
type SpecDocumentResponse struct {
	union json.RawMessage
}

// SpecDomain defines model for SpecDomain.
type SpecDomain struct {
	// ClassificationConfidence AI classification confidence score (0-1)
	ClassificationConfidence *float32 `json:"classificationConfidence,omitempty"`

	// Description Domain description
	Description *string `json:"description,omitempty"`

	// Features Features within this domain
	Features []SpecFeature `json:"features"`

	// ID Domain ID
	ID openapi_types.UUID `json:"id"`

	// Name Domain name
	Name string `json:"name"`

	// SortOrder Display order within document
	SortOrder int `json:"sortOrder"`
}

// SpecFeature defines model for SpecFeature.
type SpecFeature struct {
	// Behaviors Behaviors (converted test cases) within this feature
	Behaviors []SpecBehavior `json:"behaviors"`

	// Description Feature description
	Description *string `json:"description,omitempty"`

	// ID Feature ID
	ID openapi_types.UUID `json:"id"`

	// Name Feature name
	Name string `json:"name"`

	// SortOrder Display order within domain
	SortOrder int `json:"sortOrder"`
}

// SpecGenerationStatus defines model for SpecGenerationStatus.
type SpecGenerationStatus struct {
	CompletedAt  *time.Time `json:"completedAt,omitempty"`
	ErrorMessage *string    `json:"errorMessage,omitempty"`
	StartedAt    *time.Time `json:"startedAt,omitempty"`

	// Status Generation status:
	// - pending: Job queued but not started
	// - running: AI generation in progress
	// - completed: Document successfully generated
	// - failed: Generation failed
	// - not_found: No generation request exists
	Status SpecGenerationStatusEnum `json:"status"`
}

// SpecGenerationStatusEnum Generation status:
// - pending: Job queued but not started
// - running: AI generation in progress
// - completed: Document successfully generated
// - failed: Generation failed
// - not_found: No generation request exists
type SpecGenerationStatusEnum string

// SpecGenerationStatusResponse defines model for SpecGenerationStatusResponse.
type SpecGenerationStatusResponse struct {
	AnalysisID openapi_types.UUID `json:"analysisId"`

	// CompletedAt When generation completed (if completed)
	CompletedAt *time.Time `json:"completedAt,omitempty"`

	// ErrorMessage Error message if generation failed
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// StartedAt When generation started
	StartedAt *time.Time `json:"startedAt,omitempty"`

	// Status Generation status:
	// - pending: Job queued but not started
	// - running: AI generation in progress
	// - completed: Document successfully generated
	// - failed: Generation failed
	// - not_found: No generation request exists
	Status SpecGenerationStatusEnum `json:"status"`
}

// SpecLanguage Target language for spec document generation (24 languages supported)
type SpecLanguage string

// Summary defines model for Summary.
type Summary struct {
	// Active Number of active tests
	Active int `json:"active"`

	// Focused Number of focused tests
	Focused    int                `json:"focused"`
	Frameworks []FrameworkSummary `json:"frameworks"`

	// Skipped Number of skipped tests
	Skipped int `json:"skipped"`

	// Todo Number of todo tests
	Todo int `json:"todo"`

	// Total Total number of tests
	Total int `json:"total"`

	// Xfail Number of xfail tests
	Xfail int `json:"xfail"`
}

// TestCase defines model for TestCase.
type TestCase struct {
	// FilePath Path to the test file
	FilePath string `json:"filePath"`

	// Framework Testing framework identifier
	Framework Framework `json:"framework"`

	// Line Line number where the test is defined
	Line int `json:"line"`

	// Modifier Test modifier (e.g., only, skip)
	Modifier *string `json:"modifier,omitempty"`

	// Name Test case name
	Name string `json:"name"`

	// Status Test status indicator:
	// - active: Normal test that will run
	// - focused: Test marked to run exclusively (e.g., it.only)
	// - skipped: Test marked to be skipped (e.g., it.skip)
	// - todo: Placeholder test to be implemented
	// - xfail: Expected to fail (pytest xfail)
	Status TestStatus `json:"status"`
}

// TestStatus Test status indicator:
// - active: Normal test that will run
// - focused: Test marked to run exclusively (e.g., it.only)
// - skipped: Test marked to be skipped (e.g., it.skip)
// - todo: Placeholder test to be implemented
// - xfail: Expected to fail (pytest xfail)
type TestStatus string

// TestStatusSummary defines model for TestStatusSummary.
type TestStatusSummary struct {
	// Active Number of active tests
	Active int `json:"active"`

	// Focused Number of focused tests (.only())
	Focused int `json:"focused"`

	// Skipped Number of skipped tests (.skip())
	Skipped int `json:"skipped"`

	// Todo Number of todo tests
	Todo int `json:"todo"`

	// Xfail Number of expected-to-fail tests
	Xfail int `json:"xfail"`
}

// TestSuite defines model for TestSuite.
type TestSuite struct {
	// FilePath Path to the test file relative to repository root
	FilePath string `json:"filePath"`

	// Framework Testing framework identifier
	Framework Framework `json:"framework"`

	// SuiteName Name of the test suite (describe block name)
	SuiteName string     `json:"suiteName"`
	Tests     []TestCase `json:"tests"`
}

// UpdateStatus Repository update status:
// - up-to-date: Latest analysis is current with HEAD
// - new-commits: New commits available since last analysis
// - unknown: Unable to determine status
type UpdateStatus string

// UpdateStatusResponse defines model for UpdateStatusResponse.
type UpdateStatusResponse struct {
	// AnalyzedCommitSHA Commit SHA from last analysis
	AnalyzedCommitSHA *string `json:"analyzedCommitSha,omitempty"`

	// LatestCommitSHA Latest commit SHA from remote
	LatestCommitSHA *string `json:"latestCommitSha,omitempty"`

	// ParserOutdated Whether the parser version has been updated since last analysis
	ParserOutdated bool `json:"parserOutdated"`

	// Status Repository update status:
	// - up-to-date: Latest analysis is current with HEAD
	// - new-commits: New commits available since last analysis
	// - unknown: Unable to determine status
	Status UpdateStatus `json:"status"`
}

// UsageEventType Type of usage event:
// - specview: SpecView generation
// - analysis: Repository analysis
type UsageEventType string

// UsageMetric defines model for UsageMetric.
type UsageMetric struct {
	// Limit Usage limit (null for unlimited/enterprise)
	Limit *int `json:"limit"`

	// Percentage Usage percentage (null for unlimited/enterprise)
	Percentage *float32 `json:"percentage"`

	// Used Current usage count
	Used int `json:"used"`
}

// UsageStatusResponse defines model for UsageStatusResponse.
type UsageStatusResponse struct {
	Analysis UsageMetric `json:"analysis"`
	Plan     PlanInfo    `json:"plan"`

	// ResetAt When the current usage period resets
	ResetAt  time.Time   `json:"resetAt"`
	Specview UsageMetric `json:"specview"`
}

// UserAnalyzedRepositoriesResponse defines model for UserAnalyzedRepositoriesResponse.
type UserAnalyzedRepositoriesResponse struct {
	// Data Analyzed repositories in the current page
	Data []RepositoryCard `json:"data"`

	// HasNext Whether more pages are available
	HasNext bool `json:"hasNext"`

	// NextCursor Cursor for fetching the next page (null if no more pages)
	NextCursor *string `json:"nextCursor"`
}

// UserInfo defines model for UserInfo.
type UserInfo struct {
	// AvatarURL GitHub avatar URL
	AvatarURL string `json:"avatarUrl"`

	// ID Internal user ID
	ID string `json:"id"`

	// Login GitHub username
	Login string `json:"login"`

	// Name GitHub display name (optional)
	Name *string `json:"name,omitempty"`
}

// UserSubscriptionResponse defines model for UserSubscriptionResponse.
type UserSubscriptionResponse struct {
	// CurrentPeriodEnd End of the current billing period (when usage resets)
	CurrentPeriodEnd time.Time `json:"currentPeriodEnd"`

	// CurrentPeriodStart Start of the current billing period
	CurrentPeriodStart time.Time `json:"currentPeriodStart"`
	Plan               PlanInfo  `json:"plan"`
}

// VersionHistoryResponse defines model for VersionHistoryResponse.
type VersionHistoryResponse struct {
	// Data List of versions ordered by version number descending
	Data []VersionInfo `json:"data"`

	// Language Target language for spec document generation (24 languages supported)
	Language SpecLanguage `json:"language"`

	// LatestVersion The latest version number for this language
	LatestVersion int `json:"latestVersion"`
}

// VersionInfo defines model for VersionInfo.
type VersionInfo struct {
	// CreatedAt When this version was created
	CreatedAt time.Time `json:"createdAt"`

	// ModelID AI model ID used for this version
	ModelID *string `json:"modelId,omitempty"`

	// Version Version number
	Version int `json:"version"`
}

// ViewFilterParam Filter repositories by analyzer (who analyzed):
// - all: All analyzed repositories
// - my: Only repositories analyzed by the current user
// - community: Only repositories analyzed by other users
type ViewFilterParam string

// WebhookAccount defines model for WebhookAccount.
type WebhookAccount struct {
	// AvatarURL Account avatar URL
	AvatarURL *string `json:"avatar_url,omitempty"`

	// ID GitHub account ID
	ID int64 `json:"id"`

	// Login Account login name
	Login string `json:"login"`

	// Type Account type
	Type WebhookAccountType `json:"type"`
}

// WebhookAccountType Account type
type WebhookAccountType string

// WebhookInstallation defines model for WebhookInstallation.
type WebhookInstallation struct {
	Account WebhookAccount `json:"account"`

	// ID GitHub App installation ID
	ID int64 `json:"id"`

	// SuspendedAt When the installation was suspended
	SuspendedAt *time.Time `json:"suspended_at"`
}

// WebhookRepository defines model for WebhookRepository.
type WebhookRepository struct {
	// FullName Full repository name (owner/repo)
	FullName string `json:"full_name"`

	// ID GitHub repository ID
	ID int64 `json:"id"`

	// Name Repository name
	Name string `json:"name"`

	// Private Whether the repository is private
	Private *bool `json:"private,omitempty"`
}

// WebhookResponse defines model for WebhookResponse.
type WebhookResponse struct {
	// Message Optional message about the processing result
	Message *string `json:"message,omitempty"`

	// Success Whether the webhook was processed successfully
	Success bool `json:"success"`
}

// WebhookSender defines model for WebhookSender.
type WebhookSender struct {
	// ID GitHub user ID of the sender
	ID int64 `json:"id"`

	// Login GitHub username of the sender
	Login string `json:"login"`
}

// Owner defines model for Owner.
type Owner = string

// Repo defines model for Repo.
type Repo = string

// BadRequest defines model for BadRequest.
type BadRequest = ProblemDetail

// Forbidden defines model for Forbidden.
type Forbidden = ProblemDetail

// InternalError defines model for InternalError.
type InternalError = ProblemDetail

// NotFound defines model for NotFound.
type NotFound = ProblemDetail

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = ProblemDetail

// Unauthorized defines model for Unauthorized.
type Unauthorized = ProblemDetail

// AuthCallbackParams defines parameters for AuthCallback.
type AuthCallbackParams struct {
	// Code OAuth authorization code from GitHub
	Code string `form:"code" json:"code"`

	// State OAuth state for CSRF protection
	State string `form:"state" json:"state"`
}

// GetRecentRepositoriesParams defines parameters for GetRecentRepositories.
type GetRecentRepositoriesParams struct {
	// Cursor Pagination cursor for next page (opaque string from previous response)
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of repositories to return per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy Field to sort by (default is recent)
	SortBy *SortByParam `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder Sort direction (default depends on sortBy - desc for recent/tests, asc for name)
	SortOrder *SortOrderParam `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// View Filter repositories by analyzer (who analyzed the repository)
	View *ViewFilterParam `form:"view,omitempty" json:"view,omitempty"`

	// Ownership Filter repositories by ownership type
	Ownership *OwnershipFilterParam `form:"ownership,omitempty" json:"ownership,omitempty"`
}

// GetSpecGenerationStatusParams defines parameters for GetSpecGenerationStatus.
type GetSpecGenerationStatusParams struct {
	// Language Language to check status for (e.g., English, Korean)
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// GetSpecDocumentParams defines parameters for GetSpecDocument.
type GetSpecDocumentParams struct {
	// Language Filter by language. If not specified, returns the most recent document.
	Language *SpecLanguage `form:"language,omitempty" json:"language,omitempty"`

	// Version Specific version number to retrieve. Requires language parameter. If not specified, returns the latest version.
	Version *int `form:"version,omitempty" json:"version,omitempty"`
}

// GetSpecVersionsParams defines parameters for GetSpecVersions.
type GetSpecVersionsParams struct {
	// Language Language to get version history for
	Language SpecLanguage `form:"language" json:"language"`
}

// GetUserAnalyzedRepositoriesParams defines parameters for GetUserAnalyzedRepositories.
type GetUserAnalyzedRepositoriesParams struct {
	// Cursor Pagination cursor for next page (opaque string from previous response)
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of repositories to return per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Ownership Filter repositories by ownership:
	// - all: All analyzed repositories (personal and organization)
	// - mine: Only repositories owned by the user
	// - organization: Only repositories owned by organizations
	Ownership *GetUserAnalyzedRepositoriesParamsOwnership `form:"ownership,omitempty" json:"ownership,omitempty"`
}

// GetUserAnalyzedRepositoriesParamsOwnership defines parameters for GetUserAnalyzedRepositories.
type GetUserAnalyzedRepositoriesParamsOwnership string

// GetUserGitHubOrganizationsParams defines parameters for GetUserGitHubOrganizations.
type GetUserGitHubOrganizationsParams struct {
	// Refresh Force refresh from GitHub API, bypassing cache
	Refresh *bool `form:"refresh,omitempty" json:"refresh,omitempty"`
}

// GetOrganizationRepositoriesParams defines parameters for GetOrganizationRepositories.
type GetOrganizationRepositoriesParams struct {
	// Refresh Force refresh from GitHub API, bypassing cache
	Refresh *bool `form:"refresh,omitempty" json:"refresh,omitempty"`
}

// GetUserGitHubRepositoriesParams defines parameters for GetUserGitHubRepositories.
type GetUserGitHubRepositoriesParams struct {
	// Refresh Force refresh from GitHub API, bypassing cache
	Refresh *bool `form:"refresh,omitempty" json:"refresh,omitempty"`
}

// HandleGitHubAppWebhookParams defines parameters for HandleGitHubAppWebhook.
type HandleGitHubAppWebhookParams struct {
	// XGitHubEvent GitHub event type (e.g., installation, installation_repositories)
	XGitHubEvent string `json:"X-GitHub-Event"`

	// XHubSignature256 HMAC-SHA256 signature for payload verification
	XHubSignature256 string `json:"X-Hub-Signature-256"`

	// XGitHubDelivery Unique delivery ID for this webhook event
	XGitHubDelivery openapi_types.UUID `json:"X-GitHub-Delivery"`
}

// AuthDevLoginJSONRequestBody defines body for AuthDevLogin for application/json ContentType.
type AuthDevLoginJSONRequestBody = DevLoginRequest

// RequestSpecGenerationJSONRequestBody defines body for RequestSpecGeneration for application/json ContentType.
type RequestSpecGenerationJSONRequestBody = RequestSpecGenerationRequest

// CheckQuotaJSONRequestBody defines body for CheckQuota for application/json ContentType.
type CheckQuotaJSONRequestBody = CheckQuotaRequest

// AddUserAnalyzedRepositoryJSONRequestBody defines body for AddUserAnalyzedRepository for application/json ContentType.
type AddUserAnalyzedRepositoryJSONRequestBody = AddAnalyzedRepositoryRequest

// HandleGitHubAppWebhookJSONRequestBody defines body for HandleGitHubAppWebhook for application/json ContentType.
type HandleGitHubAppWebhookJSONRequestBody = GitHubWebhookPayload

// AsCompletedResponse returns the union data inside the AnalysisResponse as a CompletedResponse
func (t AnalysisResponse) AsCompletedResponse() (CompletedResponse, error) {
	var body CompletedResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCompletedResponse overwrites any union data inside the AnalysisResponse as the provided CompletedResponse
func (t *AnalysisResponse) FromCompletedResponse(v CompletedResponse) error {
	v.Status = "completed"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCompletedResponse performs a merge with any union data inside the AnalysisResponse, using the provided CompletedResponse
func (t *AnalysisResponse) MergeCompletedResponse(v CompletedResponse) error {
	v.Status = "completed"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAnalyzingResponse returns the union data inside the AnalysisResponse as a AnalyzingResponse
func (t AnalysisResponse) AsAnalyzingResponse() (AnalyzingResponse, error) {
	var body AnalyzingResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnalyzingResponse overwrites any union data inside the AnalysisResponse as the provided AnalyzingResponse
func (t *AnalysisResponse) FromAnalyzingResponse(v AnalyzingResponse) error {
	v.Status = "analyzing"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnalyzingResponse performs a merge with any union data inside the AnalysisResponse, using the provided AnalyzingResponse
func (t *AnalysisResponse) MergeAnalyzingResponse(v AnalyzingResponse) error {
	v.Status = "analyzing"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQueuedResponse returns the union data inside the AnalysisResponse as a QueuedResponse
func (t AnalysisResponse) AsQueuedResponse() (QueuedResponse, error) {
	var body QueuedResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQueuedResponse overwrites any union data inside the AnalysisResponse as the provided QueuedResponse
func (t *AnalysisResponse) FromQueuedResponse(v QueuedResponse) error {
	v.Status = "queued"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQueuedResponse performs a merge with any union data inside the AnalysisResponse, using the provided QueuedResponse
func (t *AnalysisResponse) MergeQueuedResponse(v QueuedResponse) error {
	v.Status = "queued"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFailedResponse returns the union data inside the AnalysisResponse as a FailedResponse
func (t AnalysisResponse) AsFailedResponse() (FailedResponse, error) {
	var body FailedResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFailedResponse overwrites any union data inside the AnalysisResponse as the provided FailedResponse
func (t *AnalysisResponse) FromFailedResponse(v FailedResponse) error {
	v.Status = "failed"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFailedResponse performs a merge with any union data inside the AnalysisResponse, using the provided FailedResponse
func (t *AnalysisResponse) MergeFailedResponse(v FailedResponse) error {
	v.Status = "failed"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AnalysisResponse) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"status"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AnalysisResponse) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "analyzing":
		return t.AsAnalyzingResponse()
	case "completed":
		return t.AsCompletedResponse()
	case "failed":
		return t.AsFailedResponse()
	case "queued":
		return t.AsQueuedResponse()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AnalysisResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AnalysisResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSpecDocumentCompleted returns the union data inside the SpecDocumentResponse as a SpecDocumentCompleted
func (t SpecDocumentResponse) AsSpecDocumentCompleted() (SpecDocumentCompleted, error) {
	var body SpecDocumentCompleted
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSpecDocumentCompleted overwrites any union data inside the SpecDocumentResponse as the provided SpecDocumentCompleted
func (t *SpecDocumentResponse) FromSpecDocumentCompleted(v SpecDocumentCompleted) error {
	v.Status = "completed"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSpecDocumentCompleted performs a merge with any union data inside the SpecDocumentResponse, using the provided SpecDocumentCompleted
func (t *SpecDocumentResponse) MergeSpecDocumentCompleted(v SpecDocumentCompleted) error {
	v.Status = "completed"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSpecDocumentGenerating returns the union data inside the SpecDocumentResponse as a SpecDocumentGenerating
func (t SpecDocumentResponse) AsSpecDocumentGenerating() (SpecDocumentGenerating, error) {
	var body SpecDocumentGenerating
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSpecDocumentGenerating overwrites any union data inside the SpecDocumentResponse as the provided SpecDocumentGenerating
func (t *SpecDocumentResponse) FromSpecDocumentGenerating(v SpecDocumentGenerating) error {
	v.Status = "generating"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSpecDocumentGenerating performs a merge with any union data inside the SpecDocumentResponse, using the provided SpecDocumentGenerating
func (t *SpecDocumentResponse) MergeSpecDocumentGenerating(v SpecDocumentGenerating) error {
	v.Status = "generating"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SpecDocumentResponse) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"status"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SpecDocumentResponse) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "completed":
		return t.AsSpecDocumentCompleted()
	case "generating":
		return t.AsSpecDocumentGenerating()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SpecDocumentResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SpecDocumentResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Analyze repository test specifications
	// (GET /api/analyze/{owner}/{repo})
	AnalyzeRepository(w http.ResponseWriter, r *http.Request, owner Owner, repo Repo)
	// Get analysis status
	// (GET /api/analyze/{owner}/{repo}/status)
	GetAnalysisStatus(w http.ResponseWriter, r *http.Request, owner Owner, repo Repo)
	// GitHub OAuth callback
	// (GET /api/auth/callback)
	AuthCallback(w http.ResponseWriter, r *http.Request, params AuthCallbackParams)
	// Development-only test login
	// (POST /api/auth/dev-login)
	AuthDevLogin(w http.ResponseWriter, r *http.Request)
	// Initiate GitHub OAuth login
	// (GET /api/auth/login)
	AuthLogin(w http.ResponseWriter, r *http.Request)
	// Logout and clear authentication
	// (POST /api/auth/logout)
	AuthLogout(w http.ResponseWriter, r *http.Request)
	// Get current user info
	// (GET /api/auth/me)
	AuthMe(w http.ResponseWriter, r *http.Request)
	// Refresh authentication tokens
	// (POST /api/auth/refresh)
	AuthRefresh(w http.ResponseWriter, r *http.Request)
	// Get subscription plan pricing
	// (GET /api/pricing)
	GetPricing(w http.ResponseWriter, r *http.Request)
	// Get recently analyzed repositories
	// (GET /api/repositories/recent)
	GetRecentRepositories(w http.ResponseWriter, r *http.Request, params GetRecentRepositoriesParams)
	// Get repository statistics
	// (GET /api/repositories/stats)
	GetRepositoryStats(w http.ResponseWriter, r *http.Request)
	// Remove bookmark
	// (DELETE /api/repositories/{owner}/{repo}/bookmark)
	RemoveBookmark(w http.ResponseWriter, r *http.Request, owner Owner, repo Repo)
	// Bookmark a repository
	// (POST /api/repositories/{owner}/{repo}/bookmark)
	AddBookmark(w http.ResponseWriter, r *http.Request, owner Owner, repo Repo)
	// Trigger repository re-analysis
	// (POST /api/repositories/{owner}/{repo}/reanalyze)
	ReanalyzeRepository(w http.ResponseWriter, r *http.Request, owner Owner, repo Repo)
	// Check repository update status
	// (GET /api/repositories/{owner}/{repo}/update-status)
	GetUpdateStatus(w http.ResponseWriter, r *http.Request, owner Owner, repo Repo)
	// Request spec document generation
	// (POST /api/spec-view/generate)
	RequestSpecGeneration(w http.ResponseWriter, r *http.Request)
	// Get spec generation status
	// (GET /api/spec-view/status/{analysisId})
	GetSpecGenerationStatus(w http.ResponseWriter, r *http.Request, analysisID openapi_types.UUID, params GetSpecGenerationStatusParams)
	// Get specification document for analysis
	// (GET /api/spec-view/{analysisId})
	GetSpecDocument(w http.ResponseWriter, r *http.Request, analysisID openapi_types.UUID, params GetSpecDocumentParams)
	// Get version history for a specific language
	// (GET /api/spec-view/{analysisId}/versions)
	GetSpecVersions(w http.ResponseWriter, r *http.Request, analysisID openapi_types.UUID, params GetSpecVersionsParams)
	// Check usage quota before operation
	// (POST /api/usage/check-quota)
	CheckQuota(w http.ResponseWriter, r *http.Request)
	// Get current usage status
	// (GET /api/usage/current)
	GetCurrentUsage(w http.ResponseWriter, r *http.Request)
	// Get user's analyzed repositories
	// (GET /api/user/analyzed-repositories)
	GetUserAnalyzedRepositories(w http.ResponseWriter, r *http.Request, params GetUserAnalyzedRepositoriesParams)
	// Add repository to user's analysis history
	// (POST /api/user/analyzed-repositories)
	AddUserAnalyzedRepository(w http.ResponseWriter, r *http.Request)
	// Get user's bookmarked repositories
	// (GET /api/user/bookmarks)
	GetUserBookmarks(w http.ResponseWriter, r *http.Request)
	// Get GitHub App installation URL
	// (GET /api/user/github-app/install-url)
	GetGitHubAppInstallURL(w http.ResponseWriter, r *http.Request)
	// Get user's GitHub App installations
	// (GET /api/user/github-app/installations)
	GetUserGitHubAppInstallations(w http.ResponseWriter, r *http.Request)
	// Get user's GitHub organizations
	// (GET /api/user/github/organizations)
	GetUserGitHubOrganizations(w http.ResponseWriter, r *http.Request, params GetUserGitHubOrganizationsParams)
	// Get organization's repositories
	// (GET /api/user/github/organizations/{org}/repositories)
	GetOrganizationRepositories(w http.ResponseWriter, r *http.Request, org string, params GetOrganizationRepositoriesParams)
	// Get user's GitHub repositories
	// (GET /api/user/github/repositories)
	GetUserGitHubRepositories(w http.ResponseWriter, r *http.Request, params GetUserGitHubRepositoriesParams)
	// Get user's subscription details
	// (GET /api/user/subscription)
	GetUserSubscription(w http.ResponseWriter, r *http.Request)
	// Handle GitHub App webhook events
	// (POST /api/webhooks/github-app)
	HandleGitHubAppWebhook(w http.ResponseWriter, r *http.Request, params HandleGitHubAppWebhookParams)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Analyze repository test specifications
// (GET /api/analyze/{owner}/{repo})
func (_ Unimplemented) AnalyzeRepository(w http.ResponseWriter, r *http.Request, owner Owner, repo Repo) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get analysis status
// (GET /api/analyze/{owner}/{repo}/status)
func (_ Unimplemented) GetAnalysisStatus(w http.ResponseWriter, r *http.Request, owner Owner, repo Repo) {
	w.WriteHeader(http.StatusNotImplemented)
}

// GitHub OAuth callback
// (GET /api/auth/callback)
func (_ Unimplemented) AuthCallback(w http.ResponseWriter, r *http.Request, params AuthCallbackParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Development-only test login
// (POST /api/auth/dev-login)
func (_ Unimplemented) AuthDevLogin(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Initiate GitHub OAuth login
// (GET /api/auth/login)
func (_ Unimplemented) AuthLogin(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Logout and clear authentication
// (POST /api/auth/logout)
func (_ Unimplemented) AuthLogout(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get current user info
// (GET /api/auth/me)
func (_ Unimplemented) AuthMe(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Refresh authentication tokens
// (POST /api/auth/refresh)
func (_ Unimplemented) AuthRefresh(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get subscription plan pricing
// (GET /api/pricing)
func (_ Unimplemented) GetPricing(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get recently analyzed repositories
// (GET /api/repositories/recent)
func (_ Unimplemented) GetRecentRepositories(w http.ResponseWriter, r *http.Request, params GetRecentRepositoriesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get repository statistics
// (GET /api/repositories/stats)
func (_ Unimplemented) GetRepositoryStats(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Remove bookmark
// (DELETE /api/repositories/{owner}/{repo}/bookmark)
func (_ Unimplemented) RemoveBookmark(w http.ResponseWriter, r *http.Request, owner Owner, repo Repo) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Bookmark a repository
// (POST /api/repositories/{owner}/{repo}/bookmark)
func (_ Unimplemented) AddBookmark(w http.ResponseWriter, r *http.Request, owner Owner, repo Repo) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Trigger repository re-analysis
// (POST /api/repositories/{owner}/{repo}/reanalyze)
func (_ Unimplemented) ReanalyzeRepository(w http.ResponseWriter, r *http.Request, owner Owner, repo Repo) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Check repository update status
// (GET /api/repositories/{owner}/{repo}/update-status)
func (_ Unimplemented) GetUpdateStatus(w http.ResponseWriter, r *http.Request, owner Owner, repo Repo) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Request spec document generation
// (POST /api/spec-view/generate)
func (_ Unimplemented) RequestSpecGeneration(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get spec generation status
// (GET /api/spec-view/status/{analysisId})
func (_ Unimplemented) GetSpecGenerationStatus(w http.ResponseWriter, r *http.Request, analysisID openapi_types.UUID, params GetSpecGenerationStatusParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get specification document for analysis
// (GET /api/spec-view/{analysisId})
func (_ Unimplemented) GetSpecDocument(w http.ResponseWriter, r *http.Request, analysisID openapi_types.UUID, params GetSpecDocumentParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get version history for a specific language
// (GET /api/spec-view/{analysisId}/versions)
func (_ Unimplemented) GetSpecVersions(w http.ResponseWriter, r *http.Request, analysisID openapi_types.UUID, params GetSpecVersionsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Check usage quota before operation
// (POST /api/usage/check-quota)
func (_ Unimplemented) CheckQuota(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get current usage status
// (GET /api/usage/current)
func (_ Unimplemented) GetCurrentUsage(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get user's analyzed repositories
// (GET /api/user/analyzed-repositories)
func (_ Unimplemented) GetUserAnalyzedRepositories(w http.ResponseWriter, r *http.Request, params GetUserAnalyzedRepositoriesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Add repository to user's analysis history
// (POST /api/user/analyzed-repositories)
func (_ Unimplemented) AddUserAnalyzedRepository(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get user's bookmarked repositories
// (GET /api/user/bookmarks)
func (_ Unimplemented) GetUserBookmarks(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get GitHub App installation URL
// (GET /api/user/github-app/install-url)
func (_ Unimplemented) GetGitHubAppInstallURL(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get user's GitHub App installations
// (GET /api/user/github-app/installations)
func (_ Unimplemented) GetUserGitHubAppInstallations(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get user's GitHub organizations
// (GET /api/user/github/organizations)
func (_ Unimplemented) GetUserGitHubOrganizations(w http.ResponseWriter, r *http.Request, params GetUserGitHubOrganizationsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get organization's repositories
// (GET /api/user/github/organizations/{org}/repositories)
func (_ Unimplemented) GetOrganizationRepositories(w http.ResponseWriter, r *http.Request, org string, params GetOrganizationRepositoriesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get user's GitHub repositories
// (GET /api/user/github/repositories)
func (_ Unimplemented) GetUserGitHubRepositories(w http.ResponseWriter, r *http.Request, params GetUserGitHubRepositoriesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get user's subscription details
// (GET /api/user/subscription)
func (_ Unimplemented) GetUserSubscription(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Handle GitHub App webhook events
// (POST /api/webhooks/github-app)
func (_ Unimplemented) HandleGitHubAppWebhook(w http.ResponseWriter, r *http.Request, params HandleGitHubAppWebhookParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// AnalyzeRepository operation middleware
func (siw *ServerInterfaceWrapper) AnalyzeRepository(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "owner" -------------
	var owner Owner

	err = runtime.BindStyledParameterWithOptions("simple", "owner", chi.URLParam(r, "owner"), &owner, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "owner", Err: err})
		return
	}

	// ------------- Path parameter "repo" -------------
	var repo Repo

	err = runtime.BindStyledParameterWithOptions("simple", "repo", chi.URLParam(r, "repo"), &repo, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "repo", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AnalyzeRepository(w, r, owner, repo)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAnalysisStatus operation middleware
func (siw *ServerInterfaceWrapper) GetAnalysisStatus(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "owner" -------------
	var owner Owner

	err = runtime.BindStyledParameterWithOptions("simple", "owner", chi.URLParam(r, "owner"), &owner, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "owner", Err: err})
		return
	}

	// ------------- Path parameter "repo" -------------
	var repo Repo

	err = runtime.BindStyledParameterWithOptions("simple", "repo", chi.URLParam(r, "repo"), &repo, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "repo", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnalysisStatus(w, r, owner, repo)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AuthCallback operation middleware
func (siw *ServerInterfaceWrapper) AuthCallback(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthCallbackParams

	// ------------- Required query parameter "code" -------------

	if paramValue := r.URL.Query().Get("code"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "code"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "code", r.URL.Query(), &params.Code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// ------------- Required query parameter "state" -------------

	if paramValue := r.URL.Query().Get("state"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "state"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AuthCallback(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AuthDevLogin operation middleware
func (siw *ServerInterfaceWrapper) AuthDevLogin(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AuthDevLogin(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AuthLogin operation middleware
func (siw *ServerInterfaceWrapper) AuthLogin(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AuthLogin(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AuthLogout operation middleware
func (siw *ServerInterfaceWrapper) AuthLogout(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AuthLogout(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AuthMe operation middleware
func (siw *ServerInterfaceWrapper) AuthMe(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AuthMe(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AuthRefresh operation middleware
func (siw *ServerInterfaceWrapper) AuthRefresh(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AuthRefresh(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPricing operation middleware
func (siw *ServerInterfaceWrapper) GetPricing(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPricing(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRecentRepositories operation middleware
func (siw *ServerInterfaceWrapper) GetRecentRepositories(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRecentRepositoriesParams

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", r.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cursor", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "sortBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortBy", r.URL.Query(), &params.SortBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sortBy", Err: err})
		return
	}

	// ------------- Optional query parameter "sortOrder" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortOrder", r.URL.Query(), &params.SortOrder)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sortOrder", Err: err})
		return
	}

	// ------------- Optional query parameter "view" -------------

	err = runtime.BindQueryParameter("form", true, false, "view", r.URL.Query(), &params.View)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "view", Err: err})
		return
	}

	// ------------- Optional query parameter "ownership" -------------

	err = runtime.BindQueryParameter("form", true, false, "ownership", r.URL.Query(), &params.Ownership)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ownership", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRecentRepositories(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRepositoryStats operation middleware
func (siw *ServerInterfaceWrapper) GetRepositoryStats(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRepositoryStats(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RemoveBookmark operation middleware
func (siw *ServerInterfaceWrapper) RemoveBookmark(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "owner" -------------
	var owner Owner

	err = runtime.BindStyledParameterWithOptions("simple", "owner", chi.URLParam(r, "owner"), &owner, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "owner", Err: err})
		return
	}

	// ------------- Path parameter "repo" -------------
	var repo Repo

	err = runtime.BindStyledParameterWithOptions("simple", "repo", chi.URLParam(r, "repo"), &repo, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "repo", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RemoveBookmark(w, r, owner, repo)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AddBookmark operation middleware
func (siw *ServerInterfaceWrapper) AddBookmark(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "owner" -------------
	var owner Owner

	err = runtime.BindStyledParameterWithOptions("simple", "owner", chi.URLParam(r, "owner"), &owner, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "owner", Err: err})
		return
	}

	// ------------- Path parameter "repo" -------------
	var repo Repo

	err = runtime.BindStyledParameterWithOptions("simple", "repo", chi.URLParam(r, "repo"), &repo, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "repo", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddBookmark(w, r, owner, repo)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ReanalyzeRepository operation middleware
func (siw *ServerInterfaceWrapper) ReanalyzeRepository(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "owner" -------------
	var owner Owner

	err = runtime.BindStyledParameterWithOptions("simple", "owner", chi.URLParam(r, "owner"), &owner, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "owner", Err: err})
		return
	}

	// ------------- Path parameter "repo" -------------
	var repo Repo

	err = runtime.BindStyledParameterWithOptions("simple", "repo", chi.URLParam(r, "repo"), &repo, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "repo", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReanalyzeRepository(w, r, owner, repo)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetUpdateStatus operation middleware
func (siw *ServerInterfaceWrapper) GetUpdateStatus(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "owner" -------------
	var owner Owner

	err = runtime.BindStyledParameterWithOptions("simple", "owner", chi.URLParam(r, "owner"), &owner, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "owner", Err: err})
		return
	}

	// ------------- Path parameter "repo" -------------
	var repo Repo

	err = runtime.BindStyledParameterWithOptions("simple", "repo", chi.URLParam(r, "repo"), &repo, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "repo", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUpdateStatus(w, r, owner, repo)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RequestSpecGeneration operation middleware
func (siw *ServerInterfaceWrapper) RequestSpecGeneration(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RequestSpecGeneration(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSpecGenerationStatus operation middleware
func (siw *ServerInterfaceWrapper) GetSpecGenerationStatus(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "analysisId" -------------
	var analysisID openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "analysisId", chi.URLParam(r, "analysisId"), &analysisID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "analysisId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSpecGenerationStatusParams

	// ------------- Optional query parameter "language" -------------

	err = runtime.BindQueryParameter("form", true, false, "language", r.URL.Query(), &params.Language)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "language", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSpecGenerationStatus(w, r, analysisID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSpecDocument operation middleware
func (siw *ServerInterfaceWrapper) GetSpecDocument(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "analysisId" -------------
	var analysisID openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "analysisId", chi.URLParam(r, "analysisId"), &analysisID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "analysisId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSpecDocumentParams

	// ------------- Optional query parameter "language" -------------

	err = runtime.BindQueryParameter("form", true, false, "language", r.URL.Query(), &params.Language)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "language", Err: err})
		return
	}

	// ------------- Optional query parameter "version" -------------

	err = runtime.BindQueryParameter("form", true, false, "version", r.URL.Query(), &params.Version)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSpecDocument(w, r, analysisID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSpecVersions operation middleware
func (siw *ServerInterfaceWrapper) GetSpecVersions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "analysisId" -------------
	var analysisID openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "analysisId", chi.URLParam(r, "analysisId"), &analysisID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "analysisId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSpecVersionsParams

	// ------------- Required query parameter "language" -------------

	if paramValue := r.URL.Query().Get("language"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "language"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "language", r.URL.Query(), &params.Language)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "language", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSpecVersions(w, r, analysisID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CheckQuota operation middleware
func (siw *ServerInterfaceWrapper) CheckQuota(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CheckQuota(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetCurrentUsage operation middleware
func (siw *ServerInterfaceWrapper) GetCurrentUsage(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCurrentUsage(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetUserAnalyzedRepositories operation middleware
func (siw *ServerInterfaceWrapper) GetUserAnalyzedRepositories(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserAnalyzedRepositoriesParams

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", r.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cursor", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "ownership" -------------

	err = runtime.BindQueryParameter("form", true, false, "ownership", r.URL.Query(), &params.Ownership)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ownership", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUserAnalyzedRepositories(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AddUserAnalyzedRepository operation middleware
func (siw *ServerInterfaceWrapper) AddUserAnalyzedRepository(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddUserAnalyzedRepository(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetUserBookmarks operation middleware
func (siw *ServerInterfaceWrapper) GetUserBookmarks(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUserBookmarks(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetGitHubAppInstallURL operation middleware
func (siw *ServerInterfaceWrapper) GetGitHubAppInstallURL(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGitHubAppInstallURL(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetUserGitHubAppInstallations operation middleware
func (siw *ServerInterfaceWrapper) GetUserGitHubAppInstallations(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUserGitHubAppInstallations(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetUserGitHubOrganizations operation middleware
func (siw *ServerInterfaceWrapper) GetUserGitHubOrganizations(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserGitHubOrganizationsParams

	// ------------- Optional query parameter "refresh" -------------

	err = runtime.BindQueryParameter("form", true, false, "refresh", r.URL.Query(), &params.Refresh)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "refresh", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUserGitHubOrganizations(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetOrganizationRepositories operation middleware
func (siw *ServerInterfaceWrapper) GetOrganizationRepositories(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "org" -------------
	var org string

	err = runtime.BindStyledParameterWithOptions("simple", "org", chi.URLParam(r, "org"), &org, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "org", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOrganizationRepositoriesParams

	// ------------- Optional query parameter "refresh" -------------

	err = runtime.BindQueryParameter("form", true, false, "refresh", r.URL.Query(), &params.Refresh)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "refresh", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOrganizationRepositories(w, r, org, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetUserGitHubRepositories operation middleware
func (siw *ServerInterfaceWrapper) GetUserGitHubRepositories(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserGitHubRepositoriesParams

	// ------------- Optional query parameter "refresh" -------------

	err = runtime.BindQueryParameter("form", true, false, "refresh", r.URL.Query(), &params.Refresh)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "refresh", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUserGitHubRepositories(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetUserSubscription operation middleware
func (siw *ServerInterfaceWrapper) GetUserSubscription(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, CookieAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUserSubscription(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HandleGitHubAppWebhook operation middleware
func (siw *ServerInterfaceWrapper) HandleGitHubAppWebhook(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params HandleGitHubAppWebhookParams

	headers := r.Header

	// ------------- Required header parameter "X-GitHub-Event" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-GitHub-Event")]; found {
		var XGitHubEvent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-GitHub-Event", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-GitHub-Event", valueList[0], &XGitHubEvent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-GitHub-Event", Err: err})
			return
		}

		params.XGitHubEvent = XGitHubEvent

	} else {
		err := fmt.Errorf("Header parameter X-GitHub-Event is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-GitHub-Event", Err: err})
		return
	}

	// ------------- Required header parameter "X-Hub-Signature-256" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Hub-Signature-256")]; found {
		var XHubSignature256 string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Hub-Signature-256", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Hub-Signature-256", valueList[0], &XHubSignature256, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Hub-Signature-256", Err: err})
			return
		}

		params.XHubSignature256 = XHubSignature256

	} else {
		err := fmt.Errorf("Header parameter X-Hub-Signature-256 is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Hub-Signature-256", Err: err})
		return
	}

	// ------------- Required header parameter "X-GitHub-Delivery" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-GitHub-Delivery")]; found {
		var XGitHubDelivery openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-GitHub-Delivery", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-GitHub-Delivery", valueList[0], &XGitHubDelivery, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-GitHub-Delivery", Err: err})
			return
		}

		params.XGitHubDelivery = XGitHubDelivery

	} else {
		err := fmt.Errorf("Header parameter X-GitHub-Delivery is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-GitHub-Delivery", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HandleGitHubAppWebhook(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/analyze/{owner}/{repo}", wrapper.AnalyzeRepository)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/analyze/{owner}/{repo}/status", wrapper.GetAnalysisStatus)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/auth/callback", wrapper.AuthCallback)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/auth/dev-login", wrapper.AuthDevLogin)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/auth/login", wrapper.AuthLogin)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/auth/logout", wrapper.AuthLogout)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/auth/me", wrapper.AuthMe)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/auth/refresh", wrapper.AuthRefresh)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/pricing", wrapper.GetPricing)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/repositories/recent", wrapper.GetRecentRepositories)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/repositories/stats", wrapper.GetRepositoryStats)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/repositories/{owner}/{repo}/bookmark", wrapper.RemoveBookmark)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/repositories/{owner}/{repo}/bookmark", wrapper.AddBookmark)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/repositories/{owner}/{repo}/reanalyze", wrapper.ReanalyzeRepository)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/repositories/{owner}/{repo}/update-status", wrapper.GetUpdateStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/spec-view/generate", wrapper.RequestSpecGeneration)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/spec-view/status/{analysisId}", wrapper.GetSpecGenerationStatus)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/spec-view/{analysisId}", wrapper.GetSpecDocument)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/spec-view/{analysisId}/versions", wrapper.GetSpecVersions)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/usage/check-quota", wrapper.CheckQuota)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/usage/current", wrapper.GetCurrentUsage)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/user/analyzed-repositories", wrapper.GetUserAnalyzedRepositories)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/user/analyzed-repositories", wrapper.AddUserAnalyzedRepository)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/user/bookmarks", wrapper.GetUserBookmarks)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/user/github-app/install-url", wrapper.GetGitHubAppInstallURL)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/user/github-app/installations", wrapper.GetUserGitHubAppInstallations)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/user/github/organizations", wrapper.GetUserGitHubOrganizations)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/user/github/organizations/{org}/repositories", wrapper.GetOrganizationRepositories)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/user/github/repositories", wrapper.GetUserGitHubRepositories)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/user/subscription", wrapper.GetUserSubscription)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/webhooks/github-app", wrapper.HandleGitHubAppWebhook)
	})

	return r
}

type BadRequestApplicationProblemPlusJSONResponse ProblemDetail

type ForbiddenApplicationProblemPlusJSONResponse ProblemDetail

type InternalErrorApplicationProblemPlusJSONResponse ProblemDetail

type NotFoundApplicationProblemPlusJSONResponse ProblemDetail

type TooManyRequestsApplicationProblemPlusJSONResponse ProblemDetail

type UnauthorizedApplicationProblemPlusJSONResponse ProblemDetail

type AnalyzeRepositoryRequestObject struct {
	Owner Owner `json:"owner"`
	Repo  Repo  `json:"repo"`
}

type AnalyzeRepositoryResponseObject interface {
	VisitAnalyzeRepositoryResponse(w http.ResponseWriter) error
}

type AnalyzeRepository200JSONResponse CompletedResponse

func (response AnalyzeRepository200JSONResponse) VisitAnalyzeRepositoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AnalyzeRepository202JSONResponse struct {
	union json.RawMessage
}

func (response AnalyzeRepository202JSONResponse) VisitAnalyzeRepositoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(202)

	return json.NewEncoder(w).Encode(response.union)
}

type AnalyzeRepository400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response AnalyzeRepository400ApplicationProblemPlusJSONResponse) VisitAnalyzeRepositoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AnalyzeRepository429ApplicationProblemPlusJSONResponse struct {
	TooManyRequestsApplicationProblemPlusJSONResponse
}

func (response AnalyzeRepository429ApplicationProblemPlusJSONResponse) VisitAnalyzeRepositoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AnalyzeRepository500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response AnalyzeRepository500ApplicationProblemPlusJSONResponse) VisitAnalyzeRepositoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetAnalysisStatusRequestObject struct {
	Owner Owner `json:"owner"`
	Repo  Repo  `json:"repo"`
}

type GetAnalysisStatusResponseObject interface {
	VisitGetAnalysisStatusResponse(w http.ResponseWriter) error
}

type GetAnalysisStatus200JSONResponse AnalysisResponse

func (response GetAnalysisStatus200JSONResponse) VisitGetAnalysisStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetAnalysisStatus400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response GetAnalysisStatus400ApplicationProblemPlusJSONResponse) VisitGetAnalysisStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetAnalysisStatus404ApplicationProblemPlusJSONResponse struct {
	NotFoundApplicationProblemPlusJSONResponse
}

func (response GetAnalysisStatus404ApplicationProblemPlusJSONResponse) VisitGetAnalysisStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetAnalysisStatus500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response GetAnalysisStatus500ApplicationProblemPlusJSONResponse) VisitGetAnalysisStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AuthCallbackRequestObject struct {
	Params AuthCallbackParams
}

type AuthCallbackResponseObject interface {
	VisitAuthCallbackResponse(w http.ResponseWriter) error
}

type AuthCallback302ResponseHeaders struct {
	Location  string
	SetCookie string
}

type AuthCallback302Response struct {
	Headers AuthCallback302ResponseHeaders
}

func (response AuthCallback302Response) VisitAuthCallbackResponse(w http.ResponseWriter) error {
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.Header().Set("Set-Cookie", fmt.Sprint(response.Headers.SetCookie))
	w.WriteHeader(302)
	return nil
}

type AuthCallback400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response AuthCallback400ApplicationProblemPlusJSONResponse) VisitAuthCallbackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AuthCallback500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response AuthCallback500ApplicationProblemPlusJSONResponse) VisitAuthCallbackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AuthDevLoginRequestObject struct {
	Body *AuthDevLoginJSONRequestBody
}

type AuthDevLoginResponseObject interface {
	VisitAuthDevLoginResponse(w http.ResponseWriter) error
}

type AuthDevLogin200ResponseHeaders struct {
	SetCookie string
}

type AuthDevLogin200JSONResponse struct {
	Body    DevLoginResponse
	Headers AuthDevLogin200ResponseHeaders
}

func (response AuthDevLogin200JSONResponse) VisitAuthDevLoginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Set-Cookie", fmt.Sprint(response.Headers.SetCookie))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type AuthDevLogin403ApplicationProblemPlusJSONResponse struct {
	ForbiddenApplicationProblemPlusJSONResponse
}

func (response AuthDevLogin403ApplicationProblemPlusJSONResponse) VisitAuthDevLoginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AuthDevLogin500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response AuthDevLogin500ApplicationProblemPlusJSONResponse) VisitAuthDevLoginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AuthLoginRequestObject struct {
}

type AuthLoginResponseObject interface {
	VisitAuthLoginResponse(w http.ResponseWriter) error
}

type AuthLogin200JSONResponse LoginResponse

func (response AuthLogin200JSONResponse) VisitAuthLoginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AuthLogin500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response AuthLogin500ApplicationProblemPlusJSONResponse) VisitAuthLoginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AuthLogoutRequestObject struct {
}

type AuthLogoutResponseObject interface {
	VisitAuthLogoutResponse(w http.ResponseWriter) error
}

type AuthLogout200JSONResponse LogoutResponse

func (response AuthLogout200JSONResponse) VisitAuthLogoutResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AuthLogout500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response AuthLogout500ApplicationProblemPlusJSONResponse) VisitAuthLogoutResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AuthMeRequestObject struct {
}

type AuthMeResponseObject interface {
	VisitAuthMeResponse(w http.ResponseWriter) error
}

type AuthMe200JSONResponse UserInfo

func (response AuthMe200JSONResponse) VisitAuthMeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AuthMe401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response AuthMe401ApplicationProblemPlusJSONResponse) VisitAuthMeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AuthMe500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response AuthMe500ApplicationProblemPlusJSONResponse) VisitAuthMeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AuthRefreshRequestObject struct {
}

type AuthRefreshResponseObject interface {
	VisitAuthRefreshResponse(w http.ResponseWriter) error
}

type AuthRefresh200ResponseHeaders struct {
	SetCookie string
}

type AuthRefresh200JSONResponse struct {
	Body    RefreshResponse
	Headers AuthRefresh200ResponseHeaders
}

func (response AuthRefresh200JSONResponse) VisitAuthRefreshResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Set-Cookie", fmt.Sprint(response.Headers.SetCookie))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type AuthRefresh401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response AuthRefresh401ApplicationProblemPlusJSONResponse) VisitAuthRefreshResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AuthRefresh500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response AuthRefresh500ApplicationProblemPlusJSONResponse) VisitAuthRefreshResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetPricingRequestObject struct {
}

type GetPricingResponseObject interface {
	VisitGetPricingResponse(w http.ResponseWriter) error
}

type GetPricing200JSONResponse PricingResponse

func (response GetPricing200JSONResponse) VisitGetPricingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetPricing500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response GetPricing500ApplicationProblemPlusJSONResponse) VisitGetPricingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetRecentRepositoriesRequestObject struct {
	Params GetRecentRepositoriesParams
}

type GetRecentRepositoriesResponseObject interface {
	VisitGetRecentRepositoriesResponse(w http.ResponseWriter) error
}

type GetRecentRepositories200JSONResponse PaginatedRepositoriesResponse

func (response GetRecentRepositories200JSONResponse) VisitGetRecentRepositoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetRecentRepositories400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response GetRecentRepositories400ApplicationProblemPlusJSONResponse) VisitGetRecentRepositoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetRecentRepositories401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetRecentRepositories401ApplicationProblemPlusJSONResponse) VisitGetRecentRepositoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetRecentRepositories500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response GetRecentRepositories500ApplicationProblemPlusJSONResponse) VisitGetRecentRepositoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetRepositoryStatsRequestObject struct {
}

type GetRepositoryStatsResponseObject interface {
	VisitGetRepositoryStatsResponse(w http.ResponseWriter) error
}

type GetRepositoryStats200JSONResponse RepositoryStatsResponse

func (response GetRepositoryStats200JSONResponse) VisitGetRepositoryStatsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetRepositoryStats401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetRepositoryStats401ApplicationProblemPlusJSONResponse) VisitGetRepositoryStatsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetRepositoryStats500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response GetRepositoryStats500ApplicationProblemPlusJSONResponse) VisitGetRepositoryStatsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type RemoveBookmarkRequestObject struct {
	Owner Owner `json:"owner"`
	Repo  Repo  `json:"repo"`
}

type RemoveBookmarkResponseObject interface {
	VisitRemoveBookmarkResponse(w http.ResponseWriter) error
}

type RemoveBookmark200JSONResponse BookmarkResponse

func (response RemoveBookmark200JSONResponse) VisitRemoveBookmarkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type RemoveBookmark400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response RemoveBookmark400ApplicationProblemPlusJSONResponse) VisitRemoveBookmarkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type RemoveBookmark401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response RemoveBookmark401ApplicationProblemPlusJSONResponse) VisitRemoveBookmarkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type RemoveBookmark404ApplicationProblemPlusJSONResponse struct {
	NotFoundApplicationProblemPlusJSONResponse
}

func (response RemoveBookmark404ApplicationProblemPlusJSONResponse) VisitRemoveBookmarkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type RemoveBookmark500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response RemoveBookmark500ApplicationProblemPlusJSONResponse) VisitRemoveBookmarkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AddBookmarkRequestObject struct {
	Owner Owner `json:"owner"`
	Repo  Repo  `json:"repo"`
}

type AddBookmarkResponseObject interface {
	VisitAddBookmarkResponse(w http.ResponseWriter) error
}

type AddBookmark200JSONResponse BookmarkResponse

func (response AddBookmark200JSONResponse) VisitAddBookmarkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AddBookmark400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response AddBookmark400ApplicationProblemPlusJSONResponse) VisitAddBookmarkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AddBookmark401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response AddBookmark401ApplicationProblemPlusJSONResponse) VisitAddBookmarkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AddBookmark404ApplicationProblemPlusJSONResponse struct {
	NotFoundApplicationProblemPlusJSONResponse
}

func (response AddBookmark404ApplicationProblemPlusJSONResponse) VisitAddBookmarkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AddBookmark500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response AddBookmark500ApplicationProblemPlusJSONResponse) VisitAddBookmarkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ReanalyzeRepositoryRequestObject struct {
	Owner Owner `json:"owner"`
	Repo  Repo  `json:"repo"`
}

type ReanalyzeRepositoryResponseObject interface {
	VisitReanalyzeRepositoryResponse(w http.ResponseWriter) error
}

type ReanalyzeRepository202JSONResponse struct {
	union json.RawMessage
}

func (response ReanalyzeRepository202JSONResponse) VisitReanalyzeRepositoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(202)

	return json.NewEncoder(w).Encode(response.union)
}

type ReanalyzeRepository400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response ReanalyzeRepository400ApplicationProblemPlusJSONResponse) VisitReanalyzeRepositoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ReanalyzeRepository401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response ReanalyzeRepository401ApplicationProblemPlusJSONResponse) VisitReanalyzeRepositoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type ReanalyzeRepository404ApplicationProblemPlusJSONResponse struct {
	NotFoundApplicationProblemPlusJSONResponse
}

func (response ReanalyzeRepository404ApplicationProblemPlusJSONResponse) VisitReanalyzeRepositoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ReanalyzeRepository500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response ReanalyzeRepository500ApplicationProblemPlusJSONResponse) VisitReanalyzeRepositoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetUpdateStatusRequestObject struct {
	Owner Owner `json:"owner"`
	Repo  Repo  `json:"repo"`
}

type GetUpdateStatusResponseObject interface {
	VisitGetUpdateStatusResponse(w http.ResponseWriter) error
}

type GetUpdateStatus200JSONResponse UpdateStatusResponse

func (response GetUpdateStatus200JSONResponse) VisitGetUpdateStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetUpdateStatus400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response GetUpdateStatus400ApplicationProblemPlusJSONResponse) VisitGetUpdateStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetUpdateStatus401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetUpdateStatus401ApplicationProblemPlusJSONResponse) VisitGetUpdateStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetUpdateStatus404ApplicationProblemPlusJSONResponse struct {
	NotFoundApplicationProblemPlusJSONResponse
}

func (response GetUpdateStatus404ApplicationProblemPlusJSONResponse) VisitGetUpdateStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetUpdateStatus500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response GetUpdateStatus500ApplicationProblemPlusJSONResponse) VisitGetUpdateStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type RequestSpecGenerationRequestObject struct {
	Body *RequestSpecGenerationJSONRequestBody
}

type RequestSpecGenerationResponseObject interface {
	VisitRequestSpecGenerationResponse(w http.ResponseWriter) error
}

type RequestSpecGeneration202JSONResponse RequestSpecGenerationResponse

func (response RequestSpecGeneration202JSONResponse) VisitRequestSpecGenerationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(202)

	return json.NewEncoder(w).Encode(response)
}

type RequestSpecGeneration400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response RequestSpecGeneration400ApplicationProblemPlusJSONResponse) VisitRequestSpecGenerationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type RequestSpecGeneration401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response RequestSpecGeneration401ApplicationProblemPlusJSONResponse) VisitRequestSpecGenerationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type RequestSpecGeneration403ApplicationProblemPlusJSONResponse struct {
	ForbiddenApplicationProblemPlusJSONResponse
}

func (response RequestSpecGeneration403ApplicationProblemPlusJSONResponse) VisitRequestSpecGenerationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type RequestSpecGeneration404ApplicationProblemPlusJSONResponse struct {
	NotFoundApplicationProblemPlusJSONResponse
}

func (response RequestSpecGeneration404ApplicationProblemPlusJSONResponse) VisitRequestSpecGenerationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type RequestSpecGeneration409ApplicationProblemPlusJSONResponse ProblemDetail

func (response RequestSpecGeneration409ApplicationProblemPlusJSONResponse) VisitRequestSpecGenerationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type RequestSpecGeneration429ApplicationProblemPlusJSONResponse struct {
	TooManyRequestsApplicationProblemPlusJSONResponse
}

func (response RequestSpecGeneration429ApplicationProblemPlusJSONResponse) VisitRequestSpecGenerationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type RequestSpecGeneration500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response RequestSpecGeneration500ApplicationProblemPlusJSONResponse) VisitRequestSpecGenerationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetSpecGenerationStatusRequestObject struct {
	AnalysisID openapi_types.UUID `json:"analysisId"`
	Params     GetSpecGenerationStatusParams
}

type GetSpecGenerationStatusResponseObject interface {
	VisitGetSpecGenerationStatusResponse(w http.ResponseWriter) error
}

type GetSpecGenerationStatus200JSONResponse SpecGenerationStatusResponse

func (response GetSpecGenerationStatus200JSONResponse) VisitGetSpecGenerationStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetSpecGenerationStatus400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response GetSpecGenerationStatus400ApplicationProblemPlusJSONResponse) VisitGetSpecGenerationStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetSpecGenerationStatus401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetSpecGenerationStatus401ApplicationProblemPlusJSONResponse) VisitGetSpecGenerationStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetSpecGenerationStatus403ApplicationProblemPlusJSONResponse struct {
	ForbiddenApplicationProblemPlusJSONResponse
}

func (response GetSpecGenerationStatus403ApplicationProblemPlusJSONResponse) VisitGetSpecGenerationStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetSpecGenerationStatus404ApplicationProblemPlusJSONResponse struct {
	NotFoundApplicationProblemPlusJSONResponse
}

func (response GetSpecGenerationStatus404ApplicationProblemPlusJSONResponse) VisitGetSpecGenerationStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetSpecGenerationStatus500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response GetSpecGenerationStatus500ApplicationProblemPlusJSONResponse) VisitGetSpecGenerationStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetSpecDocumentRequestObject struct {
	AnalysisID openapi_types.UUID `json:"analysisId"`
	Params     GetSpecDocumentParams
}

type GetSpecDocumentResponseObject interface {
	VisitGetSpecDocumentResponse(w http.ResponseWriter) error
}

type GetSpecDocument200JSONResponse SpecDocumentResponse

func (response GetSpecDocument200JSONResponse) VisitGetSpecDocumentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetSpecDocument401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetSpecDocument401ApplicationProblemPlusJSONResponse) VisitGetSpecDocumentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetSpecDocument403ApplicationProblemPlusJSONResponse struct {
	ForbiddenApplicationProblemPlusJSONResponse
}

func (response GetSpecDocument403ApplicationProblemPlusJSONResponse) VisitGetSpecDocumentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetSpecDocument404ApplicationProblemPlusJSONResponse struct {
	NotFoundApplicationProblemPlusJSONResponse
}

func (response GetSpecDocument404ApplicationProblemPlusJSONResponse) VisitGetSpecDocumentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetSpecDocument500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response GetSpecDocument500ApplicationProblemPlusJSONResponse) VisitGetSpecDocumentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetSpecVersionsRequestObject struct {
	AnalysisID openapi_types.UUID `json:"analysisId"`
	Params     GetSpecVersionsParams
}

type GetSpecVersionsResponseObject interface {
	VisitGetSpecVersionsResponse(w http.ResponseWriter) error
}

type GetSpecVersions200JSONResponse VersionHistoryResponse

func (response GetSpecVersions200JSONResponse) VisitGetSpecVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetSpecVersions400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response GetSpecVersions400ApplicationProblemPlusJSONResponse) VisitGetSpecVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetSpecVersions401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetSpecVersions401ApplicationProblemPlusJSONResponse) VisitGetSpecVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetSpecVersions403ApplicationProblemPlusJSONResponse struct {
	ForbiddenApplicationProblemPlusJSONResponse
}

func (response GetSpecVersions403ApplicationProblemPlusJSONResponse) VisitGetSpecVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetSpecVersions404ApplicationProblemPlusJSONResponse struct {
	NotFoundApplicationProblemPlusJSONResponse
}

func (response GetSpecVersions404ApplicationProblemPlusJSONResponse) VisitGetSpecVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetSpecVersions500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response GetSpecVersions500ApplicationProblemPlusJSONResponse) VisitGetSpecVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CheckQuotaRequestObject struct {
	Body *CheckQuotaJSONRequestBody
}

type CheckQuotaResponseObject interface {
	VisitCheckQuotaResponse(w http.ResponseWriter) error
}

type CheckQuota200JSONResponse CheckQuotaResponse

func (response CheckQuota200JSONResponse) VisitCheckQuotaResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CheckQuota400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response CheckQuota400ApplicationProblemPlusJSONResponse) VisitCheckQuotaResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CheckQuota401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response CheckQuota401ApplicationProblemPlusJSONResponse) VisitCheckQuotaResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CheckQuota404ApplicationProblemPlusJSONResponse struct {
	NotFoundApplicationProblemPlusJSONResponse
}

func (response CheckQuota404ApplicationProblemPlusJSONResponse) VisitCheckQuotaResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CheckQuota500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response CheckQuota500ApplicationProblemPlusJSONResponse) VisitCheckQuotaResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetCurrentUsageRequestObject struct {
}

type GetCurrentUsageResponseObject interface {
	VisitGetCurrentUsageResponse(w http.ResponseWriter) error
}

type GetCurrentUsage200JSONResponse UsageStatusResponse

func (response GetCurrentUsage200JSONResponse) VisitGetCurrentUsageResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetCurrentUsage401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetCurrentUsage401ApplicationProblemPlusJSONResponse) VisitGetCurrentUsageResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetCurrentUsage404ApplicationProblemPlusJSONResponse struct {
	NotFoundApplicationProblemPlusJSONResponse
}

func (response GetCurrentUsage404ApplicationProblemPlusJSONResponse) VisitGetCurrentUsageResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetCurrentUsage500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response GetCurrentUsage500ApplicationProblemPlusJSONResponse) VisitGetCurrentUsageResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetUserAnalyzedRepositoriesRequestObject struct {
	Params GetUserAnalyzedRepositoriesParams
}

type GetUserAnalyzedRepositoriesResponseObject interface {
	VisitGetUserAnalyzedRepositoriesResponse(w http.ResponseWriter) error
}

type GetUserAnalyzedRepositories200JSONResponse UserAnalyzedRepositoriesResponse

func (response GetUserAnalyzedRepositories200JSONResponse) VisitGetUserAnalyzedRepositoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetUserAnalyzedRepositories400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response GetUserAnalyzedRepositories400ApplicationProblemPlusJSONResponse) VisitGetUserAnalyzedRepositoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetUserAnalyzedRepositories401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetUserAnalyzedRepositories401ApplicationProblemPlusJSONResponse) VisitGetUserAnalyzedRepositoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetUserAnalyzedRepositories500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response GetUserAnalyzedRepositories500ApplicationProblemPlusJSONResponse) VisitGetUserAnalyzedRepositoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AddUserAnalyzedRepositoryRequestObject struct {
	Body *AddUserAnalyzedRepositoryJSONRequestBody
}

type AddUserAnalyzedRepositoryResponseObject interface {
	VisitAddUserAnalyzedRepositoryResponse(w http.ResponseWriter) error
}

type AddUserAnalyzedRepository200JSONResponse AddAnalyzedRepositoryResponse

func (response AddUserAnalyzedRepository200JSONResponse) VisitAddUserAnalyzedRepositoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AddUserAnalyzedRepository400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response AddUserAnalyzedRepository400ApplicationProblemPlusJSONResponse) VisitAddUserAnalyzedRepositoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AddUserAnalyzedRepository401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response AddUserAnalyzedRepository401ApplicationProblemPlusJSONResponse) VisitAddUserAnalyzedRepositoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AddUserAnalyzedRepository404ApplicationProblemPlusJSONResponse struct {
	NotFoundApplicationProblemPlusJSONResponse
}

func (response AddUserAnalyzedRepository404ApplicationProblemPlusJSONResponse) VisitAddUserAnalyzedRepositoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AddUserAnalyzedRepository500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response AddUserAnalyzedRepository500ApplicationProblemPlusJSONResponse) VisitAddUserAnalyzedRepositoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetUserBookmarksRequestObject struct {
}

type GetUserBookmarksResponseObject interface {
	VisitGetUserBookmarksResponse(w http.ResponseWriter) error
}

type GetUserBookmarks200JSONResponse BookmarkedRepositoriesResponse

func (response GetUserBookmarks200JSONResponse) VisitGetUserBookmarksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetUserBookmarks401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetUserBookmarks401ApplicationProblemPlusJSONResponse) VisitGetUserBookmarksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetUserBookmarks500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response GetUserBookmarks500ApplicationProblemPlusJSONResponse) VisitGetUserBookmarksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetGitHubAppInstallURLRequestObject struct {
}

type GetGitHubAppInstallURLResponseObject interface {
	VisitGetGitHubAppInstallURLResponse(w http.ResponseWriter) error
}

type GetGitHubAppInstallURL200JSONResponse GitHubAppInstallURLResponse

func (response GetGitHubAppInstallURL200JSONResponse) VisitGetGitHubAppInstallURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetGitHubAppInstallURL401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetGitHubAppInstallURL401ApplicationProblemPlusJSONResponse) VisitGetGitHubAppInstallURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetGitHubAppInstallURL500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response GetGitHubAppInstallURL500ApplicationProblemPlusJSONResponse) VisitGetGitHubAppInstallURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetUserGitHubAppInstallationsRequestObject struct {
}

type GetUserGitHubAppInstallationsResponseObject interface {
	VisitGetUserGitHubAppInstallationsResponse(w http.ResponseWriter) error
}

type GetUserGitHubAppInstallations200JSONResponse GitHubAppInstallationsResponse

func (response GetUserGitHubAppInstallations200JSONResponse) VisitGetUserGitHubAppInstallationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetUserGitHubAppInstallations401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetUserGitHubAppInstallations401ApplicationProblemPlusJSONResponse) VisitGetUserGitHubAppInstallationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetUserGitHubAppInstallations500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response GetUserGitHubAppInstallations500ApplicationProblemPlusJSONResponse) VisitGetUserGitHubAppInstallationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetUserGitHubOrganizationsRequestObject struct {
	Params GetUserGitHubOrganizationsParams
}

type GetUserGitHubOrganizationsResponseObject interface {
	VisitGetUserGitHubOrganizationsResponse(w http.ResponseWriter) error
}

type GetUserGitHubOrganizations200JSONResponse GitHubOrganizationsResponse

func (response GetUserGitHubOrganizations200JSONResponse) VisitGetUserGitHubOrganizationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetUserGitHubOrganizations401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetUserGitHubOrganizations401ApplicationProblemPlusJSONResponse) VisitGetUserGitHubOrganizationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetUserGitHubOrganizations429ApplicationProblemPlusJSONResponse struct {
	TooManyRequestsApplicationProblemPlusJSONResponse
}

func (response GetUserGitHubOrganizations429ApplicationProblemPlusJSONResponse) VisitGetUserGitHubOrganizationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type GetUserGitHubOrganizations500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response GetUserGitHubOrganizations500ApplicationProblemPlusJSONResponse) VisitGetUserGitHubOrganizationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetOrganizationRepositoriesRequestObject struct {
	Org    string `json:"org"`
	Params GetOrganizationRepositoriesParams
}

type GetOrganizationRepositoriesResponseObject interface {
	VisitGetOrganizationRepositoriesResponse(w http.ResponseWriter) error
}

type GetOrganizationRepositories200JSONResponse GitHubRepositoriesResponse

func (response GetOrganizationRepositories200JSONResponse) VisitGetOrganizationRepositoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetOrganizationRepositories401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetOrganizationRepositories401ApplicationProblemPlusJSONResponse) VisitGetOrganizationRepositoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetOrganizationRepositories404ApplicationProblemPlusJSONResponse struct {
	NotFoundApplicationProblemPlusJSONResponse
}

func (response GetOrganizationRepositories404ApplicationProblemPlusJSONResponse) VisitGetOrganizationRepositoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetOrganizationRepositories429ApplicationProblemPlusJSONResponse struct {
	TooManyRequestsApplicationProblemPlusJSONResponse
}

func (response GetOrganizationRepositories429ApplicationProblemPlusJSONResponse) VisitGetOrganizationRepositoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type GetOrganizationRepositories500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response GetOrganizationRepositories500ApplicationProblemPlusJSONResponse) VisitGetOrganizationRepositoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetUserGitHubRepositoriesRequestObject struct {
	Params GetUserGitHubRepositoriesParams
}

type GetUserGitHubRepositoriesResponseObject interface {
	VisitGetUserGitHubRepositoriesResponse(w http.ResponseWriter) error
}

type GetUserGitHubRepositories200JSONResponse GitHubRepositoriesResponse

func (response GetUserGitHubRepositories200JSONResponse) VisitGetUserGitHubRepositoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetUserGitHubRepositories401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetUserGitHubRepositories401ApplicationProblemPlusJSONResponse) VisitGetUserGitHubRepositoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetUserGitHubRepositories429ApplicationProblemPlusJSONResponse struct {
	TooManyRequestsApplicationProblemPlusJSONResponse
}

func (response GetUserGitHubRepositories429ApplicationProblemPlusJSONResponse) VisitGetUserGitHubRepositoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type GetUserGitHubRepositories500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response GetUserGitHubRepositories500ApplicationProblemPlusJSONResponse) VisitGetUserGitHubRepositoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetUserSubscriptionRequestObject struct {
}

type GetUserSubscriptionResponseObject interface {
	VisitGetUserSubscriptionResponse(w http.ResponseWriter) error
}

type GetUserSubscription200JSONResponse UserSubscriptionResponse

func (response GetUserSubscription200JSONResponse) VisitGetUserSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetUserSubscription401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetUserSubscription401ApplicationProblemPlusJSONResponse) VisitGetUserSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetUserSubscription404ApplicationProblemPlusJSONResponse struct {
	NotFoundApplicationProblemPlusJSONResponse
}

func (response GetUserSubscription404ApplicationProblemPlusJSONResponse) VisitGetUserSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetUserSubscription500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response GetUserSubscription500ApplicationProblemPlusJSONResponse) VisitGetUserSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type HandleGitHubAppWebhookRequestObject struct {
	Params HandleGitHubAppWebhookParams
	Body   *HandleGitHubAppWebhookJSONRequestBody
}

type HandleGitHubAppWebhookResponseObject interface {
	VisitHandleGitHubAppWebhookResponse(w http.ResponseWriter) error
}

type HandleGitHubAppWebhook200JSONResponse WebhookResponse

func (response HandleGitHubAppWebhook200JSONResponse) VisitHandleGitHubAppWebhookResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type HandleGitHubAppWebhook400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response HandleGitHubAppWebhook400ApplicationProblemPlusJSONResponse) VisitHandleGitHubAppWebhookResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type HandleGitHubAppWebhook401ApplicationProblemPlusJSONResponse ProblemDetail

func (response HandleGitHubAppWebhook401ApplicationProblemPlusJSONResponse) VisitHandleGitHubAppWebhookResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type HandleGitHubAppWebhook500ApplicationProblemPlusJSONResponse struct {
	InternalErrorApplicationProblemPlusJSONResponse
}

func (response HandleGitHubAppWebhook500ApplicationProblemPlusJSONResponse) VisitHandleGitHubAppWebhookResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Analyze repository test specifications
	// (GET /api/analyze/{owner}/{repo})
	AnalyzeRepository(ctx context.Context, request AnalyzeRepositoryRequestObject) (AnalyzeRepositoryResponseObject, error)
	// Get analysis status
	// (GET /api/analyze/{owner}/{repo}/status)
	GetAnalysisStatus(ctx context.Context, request GetAnalysisStatusRequestObject) (GetAnalysisStatusResponseObject, error)
	// GitHub OAuth callback
	// (GET /api/auth/callback)
	AuthCallback(ctx context.Context, request AuthCallbackRequestObject) (AuthCallbackResponseObject, error)
	// Development-only test login
	// (POST /api/auth/dev-login)
	AuthDevLogin(ctx context.Context, request AuthDevLoginRequestObject) (AuthDevLoginResponseObject, error)
	// Initiate GitHub OAuth login
	// (GET /api/auth/login)
	AuthLogin(ctx context.Context, request AuthLoginRequestObject) (AuthLoginResponseObject, error)
	// Logout and clear authentication
	// (POST /api/auth/logout)
	AuthLogout(ctx context.Context, request AuthLogoutRequestObject) (AuthLogoutResponseObject, error)
	// Get current user info
	// (GET /api/auth/me)
	AuthMe(ctx context.Context, request AuthMeRequestObject) (AuthMeResponseObject, error)
	// Refresh authentication tokens
	// (POST /api/auth/refresh)
	AuthRefresh(ctx context.Context, request AuthRefreshRequestObject) (AuthRefreshResponseObject, error)
	// Get subscription plan pricing
	// (GET /api/pricing)
	GetPricing(ctx context.Context, request GetPricingRequestObject) (GetPricingResponseObject, error)
	// Get recently analyzed repositories
	// (GET /api/repositories/recent)
	GetRecentRepositories(ctx context.Context, request GetRecentRepositoriesRequestObject) (GetRecentRepositoriesResponseObject, error)
	// Get repository statistics
	// (GET /api/repositories/stats)
	GetRepositoryStats(ctx context.Context, request GetRepositoryStatsRequestObject) (GetRepositoryStatsResponseObject, error)
	// Remove bookmark
	// (DELETE /api/repositories/{owner}/{repo}/bookmark)
	RemoveBookmark(ctx context.Context, request RemoveBookmarkRequestObject) (RemoveBookmarkResponseObject, error)
	// Bookmark a repository
	// (POST /api/repositories/{owner}/{repo}/bookmark)
	AddBookmark(ctx context.Context, request AddBookmarkRequestObject) (AddBookmarkResponseObject, error)
	// Trigger repository re-analysis
	// (POST /api/repositories/{owner}/{repo}/reanalyze)
	ReanalyzeRepository(ctx context.Context, request ReanalyzeRepositoryRequestObject) (ReanalyzeRepositoryResponseObject, error)
	// Check repository update status
	// (GET /api/repositories/{owner}/{repo}/update-status)
	GetUpdateStatus(ctx context.Context, request GetUpdateStatusRequestObject) (GetUpdateStatusResponseObject, error)
	// Request spec document generation
	// (POST /api/spec-view/generate)
	RequestSpecGeneration(ctx context.Context, request RequestSpecGenerationRequestObject) (RequestSpecGenerationResponseObject, error)
	// Get spec generation status
	// (GET /api/spec-view/status/{analysisId})
	GetSpecGenerationStatus(ctx context.Context, request GetSpecGenerationStatusRequestObject) (GetSpecGenerationStatusResponseObject, error)
	// Get specification document for analysis
	// (GET /api/spec-view/{analysisId})
	GetSpecDocument(ctx context.Context, request GetSpecDocumentRequestObject) (GetSpecDocumentResponseObject, error)
	// Get version history for a specific language
	// (GET /api/spec-view/{analysisId}/versions)
	GetSpecVersions(ctx context.Context, request GetSpecVersionsRequestObject) (GetSpecVersionsResponseObject, error)
	// Check usage quota before operation
	// (POST /api/usage/check-quota)
	CheckQuota(ctx context.Context, request CheckQuotaRequestObject) (CheckQuotaResponseObject, error)
	// Get current usage status
	// (GET /api/usage/current)
	GetCurrentUsage(ctx context.Context, request GetCurrentUsageRequestObject) (GetCurrentUsageResponseObject, error)
	// Get user's analyzed repositories
	// (GET /api/user/analyzed-repositories)
	GetUserAnalyzedRepositories(ctx context.Context, request GetUserAnalyzedRepositoriesRequestObject) (GetUserAnalyzedRepositoriesResponseObject, error)
	// Add repository to user's analysis history
	// (POST /api/user/analyzed-repositories)
	AddUserAnalyzedRepository(ctx context.Context, request AddUserAnalyzedRepositoryRequestObject) (AddUserAnalyzedRepositoryResponseObject, error)
	// Get user's bookmarked repositories
	// (GET /api/user/bookmarks)
	GetUserBookmarks(ctx context.Context, request GetUserBookmarksRequestObject) (GetUserBookmarksResponseObject, error)
	// Get GitHub App installation URL
	// (GET /api/user/github-app/install-url)
	GetGitHubAppInstallURL(ctx context.Context, request GetGitHubAppInstallURLRequestObject) (GetGitHubAppInstallURLResponseObject, error)
	// Get user's GitHub App installations
	// (GET /api/user/github-app/installations)
	GetUserGitHubAppInstallations(ctx context.Context, request GetUserGitHubAppInstallationsRequestObject) (GetUserGitHubAppInstallationsResponseObject, error)
	// Get user's GitHub organizations
	// (GET /api/user/github/organizations)
	GetUserGitHubOrganizations(ctx context.Context, request GetUserGitHubOrganizationsRequestObject) (GetUserGitHubOrganizationsResponseObject, error)
	// Get organization's repositories
	// (GET /api/user/github/organizations/{org}/repositories)
	GetOrganizationRepositories(ctx context.Context, request GetOrganizationRepositoriesRequestObject) (GetOrganizationRepositoriesResponseObject, error)
	// Get user's GitHub repositories
	// (GET /api/user/github/repositories)
	GetUserGitHubRepositories(ctx context.Context, request GetUserGitHubRepositoriesRequestObject) (GetUserGitHubRepositoriesResponseObject, error)
	// Get user's subscription details
	// (GET /api/user/subscription)
	GetUserSubscription(ctx context.Context, request GetUserSubscriptionRequestObject) (GetUserSubscriptionResponseObject, error)
	// Handle GitHub App webhook events
	// (POST /api/webhooks/github-app)
	HandleGitHubAppWebhook(ctx context.Context, request HandleGitHubAppWebhookRequestObject) (HandleGitHubAppWebhookResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// AnalyzeRepository operation middleware
func (sh *strictHandler) AnalyzeRepository(w http.ResponseWriter, r *http.Request, owner Owner, repo Repo) {
	var request AnalyzeRepositoryRequestObject

	request.Owner = owner
	request.Repo = repo

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AnalyzeRepository(ctx, request.(AnalyzeRepositoryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AnalyzeRepository")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AnalyzeRepositoryResponseObject); ok {
		if err := validResponse.VisitAnalyzeRepositoryResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAnalysisStatus operation middleware
func (sh *strictHandler) GetAnalysisStatus(w http.ResponseWriter, r *http.Request, owner Owner, repo Repo) {
	var request GetAnalysisStatusRequestObject

	request.Owner = owner
	request.Repo = repo

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAnalysisStatus(ctx, request.(GetAnalysisStatusRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAnalysisStatus")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAnalysisStatusResponseObject); ok {
		if err := validResponse.VisitGetAnalysisStatusResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AuthCallback operation middleware
func (sh *strictHandler) AuthCallback(w http.ResponseWriter, r *http.Request, params AuthCallbackParams) {
	var request AuthCallbackRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AuthCallback(ctx, request.(AuthCallbackRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AuthCallback")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AuthCallbackResponseObject); ok {
		if err := validResponse.VisitAuthCallbackResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AuthDevLogin operation middleware
func (sh *strictHandler) AuthDevLogin(w http.ResponseWriter, r *http.Request) {
	var request AuthDevLoginRequestObject

	var body AuthDevLoginJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AuthDevLogin(ctx, request.(AuthDevLoginRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AuthDevLogin")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AuthDevLoginResponseObject); ok {
		if err := validResponse.VisitAuthDevLoginResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AuthLogin operation middleware
func (sh *strictHandler) AuthLogin(w http.ResponseWriter, r *http.Request) {
	var request AuthLoginRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AuthLogin(ctx, request.(AuthLoginRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AuthLogin")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AuthLoginResponseObject); ok {
		if err := validResponse.VisitAuthLoginResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AuthLogout operation middleware
func (sh *strictHandler) AuthLogout(w http.ResponseWriter, r *http.Request) {
	var request AuthLogoutRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AuthLogout(ctx, request.(AuthLogoutRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AuthLogout")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AuthLogoutResponseObject); ok {
		if err := validResponse.VisitAuthLogoutResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AuthMe operation middleware
func (sh *strictHandler) AuthMe(w http.ResponseWriter, r *http.Request) {
	var request AuthMeRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AuthMe(ctx, request.(AuthMeRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AuthMe")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AuthMeResponseObject); ok {
		if err := validResponse.VisitAuthMeResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AuthRefresh operation middleware
func (sh *strictHandler) AuthRefresh(w http.ResponseWriter, r *http.Request) {
	var request AuthRefreshRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AuthRefresh(ctx, request.(AuthRefreshRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AuthRefresh")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AuthRefreshResponseObject); ok {
		if err := validResponse.VisitAuthRefreshResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetPricing operation middleware
func (sh *strictHandler) GetPricing(w http.ResponseWriter, r *http.Request) {
	var request GetPricingRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetPricing(ctx, request.(GetPricingRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPricing")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetPricingResponseObject); ok {
		if err := validResponse.VisitGetPricingResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetRecentRepositories operation middleware
func (sh *strictHandler) GetRecentRepositories(w http.ResponseWriter, r *http.Request, params GetRecentRepositoriesParams) {
	var request GetRecentRepositoriesRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetRecentRepositories(ctx, request.(GetRecentRepositoriesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetRecentRepositories")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetRecentRepositoriesResponseObject); ok {
		if err := validResponse.VisitGetRecentRepositoriesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetRepositoryStats operation middleware
func (sh *strictHandler) GetRepositoryStats(w http.ResponseWriter, r *http.Request) {
	var request GetRepositoryStatsRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetRepositoryStats(ctx, request.(GetRepositoryStatsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetRepositoryStats")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetRepositoryStatsResponseObject); ok {
		if err := validResponse.VisitGetRepositoryStatsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RemoveBookmark operation middleware
func (sh *strictHandler) RemoveBookmark(w http.ResponseWriter, r *http.Request, owner Owner, repo Repo) {
	var request RemoveBookmarkRequestObject

	request.Owner = owner
	request.Repo = repo

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RemoveBookmark(ctx, request.(RemoveBookmarkRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RemoveBookmark")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RemoveBookmarkResponseObject); ok {
		if err := validResponse.VisitRemoveBookmarkResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AddBookmark operation middleware
func (sh *strictHandler) AddBookmark(w http.ResponseWriter, r *http.Request, owner Owner, repo Repo) {
	var request AddBookmarkRequestObject

	request.Owner = owner
	request.Repo = repo

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AddBookmark(ctx, request.(AddBookmarkRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AddBookmark")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AddBookmarkResponseObject); ok {
		if err := validResponse.VisitAddBookmarkResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ReanalyzeRepository operation middleware
func (sh *strictHandler) ReanalyzeRepository(w http.ResponseWriter, r *http.Request, owner Owner, repo Repo) {
	var request ReanalyzeRepositoryRequestObject

	request.Owner = owner
	request.Repo = repo

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ReanalyzeRepository(ctx, request.(ReanalyzeRepositoryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ReanalyzeRepository")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ReanalyzeRepositoryResponseObject); ok {
		if err := validResponse.VisitReanalyzeRepositoryResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetUpdateStatus operation middleware
func (sh *strictHandler) GetUpdateStatus(w http.ResponseWriter, r *http.Request, owner Owner, repo Repo) {
	var request GetUpdateStatusRequestObject

	request.Owner = owner
	request.Repo = repo

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetUpdateStatus(ctx, request.(GetUpdateStatusRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetUpdateStatus")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetUpdateStatusResponseObject); ok {
		if err := validResponse.VisitGetUpdateStatusResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RequestSpecGeneration operation middleware
func (sh *strictHandler) RequestSpecGeneration(w http.ResponseWriter, r *http.Request) {
	var request RequestSpecGenerationRequestObject

	var body RequestSpecGenerationJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RequestSpecGeneration(ctx, request.(RequestSpecGenerationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RequestSpecGeneration")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RequestSpecGenerationResponseObject); ok {
		if err := validResponse.VisitRequestSpecGenerationResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetSpecGenerationStatus operation middleware
func (sh *strictHandler) GetSpecGenerationStatus(w http.ResponseWriter, r *http.Request, analysisID openapi_types.UUID, params GetSpecGenerationStatusParams) {
	var request GetSpecGenerationStatusRequestObject

	request.AnalysisID = analysisID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetSpecGenerationStatus(ctx, request.(GetSpecGenerationStatusRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetSpecGenerationStatus")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetSpecGenerationStatusResponseObject); ok {
		if err := validResponse.VisitGetSpecGenerationStatusResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetSpecDocument operation middleware
func (sh *strictHandler) GetSpecDocument(w http.ResponseWriter, r *http.Request, analysisID openapi_types.UUID, params GetSpecDocumentParams) {
	var request GetSpecDocumentRequestObject

	request.AnalysisID = analysisID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetSpecDocument(ctx, request.(GetSpecDocumentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetSpecDocument")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetSpecDocumentResponseObject); ok {
		if err := validResponse.VisitGetSpecDocumentResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetSpecVersions operation middleware
func (sh *strictHandler) GetSpecVersions(w http.ResponseWriter, r *http.Request, analysisID openapi_types.UUID, params GetSpecVersionsParams) {
	var request GetSpecVersionsRequestObject

	request.AnalysisID = analysisID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetSpecVersions(ctx, request.(GetSpecVersionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetSpecVersions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetSpecVersionsResponseObject); ok {
		if err := validResponse.VisitGetSpecVersionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CheckQuota operation middleware
func (sh *strictHandler) CheckQuota(w http.ResponseWriter, r *http.Request) {
	var request CheckQuotaRequestObject

	var body CheckQuotaJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CheckQuota(ctx, request.(CheckQuotaRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CheckQuota")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CheckQuotaResponseObject); ok {
		if err := validResponse.VisitCheckQuotaResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetCurrentUsage operation middleware
func (sh *strictHandler) GetCurrentUsage(w http.ResponseWriter, r *http.Request) {
	var request GetCurrentUsageRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetCurrentUsage(ctx, request.(GetCurrentUsageRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetCurrentUsage")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetCurrentUsageResponseObject); ok {
		if err := validResponse.VisitGetCurrentUsageResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetUserAnalyzedRepositories operation middleware
func (sh *strictHandler) GetUserAnalyzedRepositories(w http.ResponseWriter, r *http.Request, params GetUserAnalyzedRepositoriesParams) {
	var request GetUserAnalyzedRepositoriesRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetUserAnalyzedRepositories(ctx, request.(GetUserAnalyzedRepositoriesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetUserAnalyzedRepositories")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetUserAnalyzedRepositoriesResponseObject); ok {
		if err := validResponse.VisitGetUserAnalyzedRepositoriesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AddUserAnalyzedRepository operation middleware
func (sh *strictHandler) AddUserAnalyzedRepository(w http.ResponseWriter, r *http.Request) {
	var request AddUserAnalyzedRepositoryRequestObject

	var body AddUserAnalyzedRepositoryJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AddUserAnalyzedRepository(ctx, request.(AddUserAnalyzedRepositoryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AddUserAnalyzedRepository")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AddUserAnalyzedRepositoryResponseObject); ok {
		if err := validResponse.VisitAddUserAnalyzedRepositoryResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetUserBookmarks operation middleware
func (sh *strictHandler) GetUserBookmarks(w http.ResponseWriter, r *http.Request) {
	var request GetUserBookmarksRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetUserBookmarks(ctx, request.(GetUserBookmarksRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetUserBookmarks")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetUserBookmarksResponseObject); ok {
		if err := validResponse.VisitGetUserBookmarksResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetGitHubAppInstallURL operation middleware
func (sh *strictHandler) GetGitHubAppInstallURL(w http.ResponseWriter, r *http.Request) {
	var request GetGitHubAppInstallURLRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetGitHubAppInstallURL(ctx, request.(GetGitHubAppInstallURLRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetGitHubAppInstallURL")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetGitHubAppInstallURLResponseObject); ok {
		if err := validResponse.VisitGetGitHubAppInstallURLResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetUserGitHubAppInstallations operation middleware
func (sh *strictHandler) GetUserGitHubAppInstallations(w http.ResponseWriter, r *http.Request) {
	var request GetUserGitHubAppInstallationsRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetUserGitHubAppInstallations(ctx, request.(GetUserGitHubAppInstallationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetUserGitHubAppInstallations")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetUserGitHubAppInstallationsResponseObject); ok {
		if err := validResponse.VisitGetUserGitHubAppInstallationsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetUserGitHubOrganizations operation middleware
func (sh *strictHandler) GetUserGitHubOrganizations(w http.ResponseWriter, r *http.Request, params GetUserGitHubOrganizationsParams) {
	var request GetUserGitHubOrganizationsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetUserGitHubOrganizations(ctx, request.(GetUserGitHubOrganizationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetUserGitHubOrganizations")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetUserGitHubOrganizationsResponseObject); ok {
		if err := validResponse.VisitGetUserGitHubOrganizationsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetOrganizationRepositories operation middleware
func (sh *strictHandler) GetOrganizationRepositories(w http.ResponseWriter, r *http.Request, org string, params GetOrganizationRepositoriesParams) {
	var request GetOrganizationRepositoriesRequestObject

	request.Org = org
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetOrganizationRepositories(ctx, request.(GetOrganizationRepositoriesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetOrganizationRepositories")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetOrganizationRepositoriesResponseObject); ok {
		if err := validResponse.VisitGetOrganizationRepositoriesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetUserGitHubRepositories operation middleware
func (sh *strictHandler) GetUserGitHubRepositories(w http.ResponseWriter, r *http.Request, params GetUserGitHubRepositoriesParams) {
	var request GetUserGitHubRepositoriesRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetUserGitHubRepositories(ctx, request.(GetUserGitHubRepositoriesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetUserGitHubRepositories")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetUserGitHubRepositoriesResponseObject); ok {
		if err := validResponse.VisitGetUserGitHubRepositoriesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetUserSubscription operation middleware
func (sh *strictHandler) GetUserSubscription(w http.ResponseWriter, r *http.Request) {
	var request GetUserSubscriptionRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetUserSubscription(ctx, request.(GetUserSubscriptionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetUserSubscription")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetUserSubscriptionResponseObject); ok {
		if err := validResponse.VisitGetUserSubscriptionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// HandleGitHubAppWebhook operation middleware
func (sh *strictHandler) HandleGitHubAppWebhook(w http.ResponseWriter, r *http.Request, params HandleGitHubAppWebhookParams) {
	var request HandleGitHubAppWebhookRequestObject

	request.Params = params

	var body HandleGitHubAppWebhookJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.HandleGitHubAppWebhook(ctx, request.(HandleGitHubAppWebhookRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "HandleGitHubAppWebhook")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(HandleGitHubAppWebhookResponseObject); ok {
		if err := validResponse.VisitHandleGitHubAppWebhookResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}
