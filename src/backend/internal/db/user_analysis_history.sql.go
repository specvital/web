// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: user_analysis_history.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getUserAnalyzedRepositories = `-- name: GetUserAnalyzedRepositories :many
SELECT
    uah.id AS history_id,
    uah.updated_at,
    a.id AS analysis_id,
    a.commit_sha,
    a.completed_at,
    a.total_tests,
    c.id AS codebase_id,
    c.owner,
    c.name,
    u.username AS user_username
FROM user_analysis_history uah
JOIN analyses a ON a.id = uah.analysis_id
JOIN codebases c ON c.id = a.codebase_id
JOIN users u ON u.id = uah.user_id
WHERE uah.user_id = $1
  AND a.status = 'completed'
  AND c.is_stale = false
  AND (
    $2::timestamptz IS NULL
    OR (uah.updated_at, uah.id) < ($2::timestamptz, $3::uuid)
  )
  AND (
    $4::text = 'all'
    OR ($4::text = 'mine' AND c.owner = u.username)
    OR ($4::text = 'organization' AND c.owner != u.username)
  )
ORDER BY uah.updated_at DESC, uah.id DESC
LIMIT $5
`

type GetUserAnalyzedRepositoriesParams struct {
	UserID     pgtype.UUID        `json:"user_id"`
	CursorTime pgtype.Timestamptz `json:"cursor_time"`
	CursorID   pgtype.UUID        `json:"cursor_id"`
	Ownership  string             `json:"ownership"`
	PageLimit  int32              `json:"page_limit"`
}

type GetUserAnalyzedRepositoriesRow struct {
	HistoryID    pgtype.UUID        `json:"history_id"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	AnalysisID   pgtype.UUID        `json:"analysis_id"`
	CommitSha    string             `json:"commit_sha"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
	TotalTests   int32              `json:"total_tests"`
	CodebaseID   pgtype.UUID        `json:"codebase_id"`
	Owner        string             `json:"owner"`
	Name         string             `json:"name"`
	UserUsername string             `json:"user_username"`
}

func (q *Queries) GetUserAnalyzedRepositories(ctx context.Context, arg GetUserAnalyzedRepositoriesParams) ([]GetUserAnalyzedRepositoriesRow, error) {
	rows, err := q.db.Query(ctx, getUserAnalyzedRepositories,
		arg.UserID,
		arg.CursorTime,
		arg.CursorID,
		arg.Ownership,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAnalyzedRepositoriesRow
	for rows.Next() {
		var i GetUserAnalyzedRepositoriesRow
		if err := rows.Scan(
			&i.HistoryID,
			&i.UpdatedAt,
			&i.AnalysisID,
			&i.CommitSha,
			&i.CompletedAt,
			&i.TotalTests,
			&i.CodebaseID,
			&i.Owner,
			&i.Name,
			&i.UserUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
