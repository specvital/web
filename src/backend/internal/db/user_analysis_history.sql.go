// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: user_analysis_history.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addUserAnalyzedRepository = `-- name: AddUserAnalyzedRepository :one
INSERT INTO user_analysis_history (user_id, analysis_id)
VALUES ($1, $2)
ON CONFLICT (user_id, analysis_id) DO UPDATE SET updated_at = now()
RETURNING id, analysis_id, updated_at
`

type AddUserAnalyzedRepositoryParams struct {
	UserID     pgtype.UUID `json:"user_id"`
	AnalysisID pgtype.UUID `json:"analysis_id"`
}

type AddUserAnalyzedRepositoryRow struct {
	ID         pgtype.UUID        `json:"id"`
	AnalysisID pgtype.UUID        `json:"analysis_id"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) AddUserAnalyzedRepository(ctx context.Context, arg AddUserAnalyzedRepositoryParams) (AddUserAnalyzedRepositoryRow, error) {
	row := q.db.QueryRow(ctx, addUserAnalyzedRepository, arg.UserID, arg.AnalysisID)
	var i AddUserAnalyzedRepositoryRow
	err := row.Scan(&i.ID, &i.AnalysisID, &i.UpdatedAt)
	return i, err
}

const checkUserHistoryExists = `-- name: CheckUserHistoryExists :one
SELECT EXISTS (
    SELECT 1 FROM user_analysis_history uah
    JOIN analyses a ON a.id = uah.analysis_id
    JOIN codebases c ON c.id = a.codebase_id
    WHERE uah.user_id = $1
      AND c.host = 'github.com'
      AND c.owner = $2
      AND c.name = $3
      AND a.status = 'completed'
) AS exists
`

type CheckUserHistoryExistsParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Owner  string      `json:"owner"`
	Repo   string      `json:"repo"`
}

func (q *Queries) CheckUserHistoryExists(ctx context.Context, arg CheckUserHistoryExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserHistoryExists, arg.UserID, arg.Owner, arg.Repo)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getLatestAnalysisIDByOwnerRepo = `-- name: GetLatestAnalysisIDByOwnerRepo :one
SELECT a.id
FROM analyses a
JOIN codebases c ON c.id = a.codebase_id
WHERE c.host = 'github.com'
  AND c.owner = $1
  AND c.name = $2
  AND a.status = 'completed'
ORDER BY a.completed_at DESC
LIMIT 1
`

type GetLatestAnalysisIDByOwnerRepoParams struct {
	Owner string `json:"owner"`
	Repo  string `json:"repo"`
}

func (q *Queries) GetLatestAnalysisIDByOwnerRepo(ctx context.Context, arg GetLatestAnalysisIDByOwnerRepoParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getLatestAnalysisIDByOwnerRepo, arg.Owner, arg.Repo)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getUserAnalyzedRepositories = `-- name: GetUserAnalyzedRepositories :many
SELECT
    uah.id AS history_id,
    uah.updated_at,
    a.id AS analysis_id,
    a.commit_sha,
    a.completed_at,
    a.total_tests,
    c.id AS codebase_id,
    c.owner,
    c.name,
    u.username AS user_username
FROM user_analysis_history uah
JOIN analyses a ON a.id = uah.analysis_id
JOIN codebases c ON c.id = a.codebase_id
JOIN users u ON u.id = uah.user_id
LEFT JOIN user_github_org_memberships ugom ON ugom.user_id = uah.user_id
LEFT JOIN github_organizations go ON go.id = ugom.org_id AND go.login = c.owner
WHERE uah.user_id = $1
  AND a.status = 'completed'
  AND c.is_stale = false
  AND (
    $2::timestamptz IS NULL
    OR (uah.updated_at, uah.id) < ($2::timestamptz, $3::uuid)
  )
  AND (
    $4::text = 'all'
    OR ($4::text = 'mine' AND c.owner = u.username)
    OR ($4::text = 'organization' AND go.id IS NOT NULL)
    OR ($4::text = 'others' AND c.owner != u.username AND go.id IS NULL)
  )
ORDER BY uah.updated_at DESC, uah.id DESC
LIMIT $5
`

type GetUserAnalyzedRepositoriesParams struct {
	UserID     pgtype.UUID        `json:"user_id"`
	CursorTime pgtype.Timestamptz `json:"cursor_time"`
	CursorID   pgtype.UUID        `json:"cursor_id"`
	Ownership  string             `json:"ownership"`
	PageLimit  int32              `json:"page_limit"`
}

type GetUserAnalyzedRepositoriesRow struct {
	HistoryID    pgtype.UUID        `json:"history_id"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	AnalysisID   pgtype.UUID        `json:"analysis_id"`
	CommitSha    string             `json:"commit_sha"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
	TotalTests   int32              `json:"total_tests"`
	CodebaseID   pgtype.UUID        `json:"codebase_id"`
	Owner        string             `json:"owner"`
	Name         string             `json:"name"`
	UserUsername string             `json:"user_username"`
}

func (q *Queries) GetUserAnalyzedRepositories(ctx context.Context, arg GetUserAnalyzedRepositoriesParams) ([]GetUserAnalyzedRepositoriesRow, error) {
	rows, err := q.db.Query(ctx, getUserAnalyzedRepositories,
		arg.UserID,
		arg.CursorTime,
		arg.CursorID,
		arg.Ownership,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAnalyzedRepositoriesRow
	for rows.Next() {
		var i GetUserAnalyzedRepositoriesRow
		if err := rows.Scan(
			&i.HistoryID,
			&i.UpdatedAt,
			&i.AnalysisID,
			&i.CommitSha,
			&i.CompletedAt,
			&i.TotalTests,
			&i.CodebaseID,
			&i.Owner,
			&i.Name,
			&i.UserUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
