// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: analysis.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPendingAnalysis = `-- name: CreatePendingAnalysis :one
INSERT INTO analyses (codebase_id, commit_sha, status)
VALUES ($1, '', 'pending')
RETURNING id
`

func (q *Queries) CreatePendingAnalysis(ctx context.Context, codebaseID pgtype.UUID) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createPendingAnalysis, codebaseID)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getAnalysisStatus = `-- name: GetAnalysisStatus :one
SELECT
    a.id,
    a.status,
    a.error_message,
    a.created_at,
    a.completed_at
FROM analyses a
JOIN codebases c ON c.id = a.codebase_id
WHERE c.host = $1 AND c.owner = $2 AND c.name = $3
ORDER BY a.created_at DESC
LIMIT 1
`

type GetAnalysisStatusParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

type GetAnalysisStatusRow struct {
	ID           pgtype.UUID        `json:"id"`
	Status       AnalysisStatus     `json:"status"`
	ErrorMessage pgtype.Text        `json:"error_message"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) GetAnalysisStatus(ctx context.Context, arg GetAnalysisStatusParams) (GetAnalysisStatusRow, error) {
	row := q.db.QueryRow(ctx, getAnalysisStatus, arg.Host, arg.Owner, arg.Name)
	var i GetAnalysisStatusRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getLatestCompletedAnalysis = `-- name: GetLatestCompletedAnalysis :one
SELECT
    a.id,
    a.commit_sha,
    a.completed_at,
    a.total_suites,
    a.total_tests,
    c.owner,
    c.name as repo
FROM analyses a
JOIN codebases c ON c.id = a.codebase_id
WHERE c.host = $1 AND c.owner = $2 AND c.name = $3
  AND a.status = 'completed'
ORDER BY a.created_at DESC
LIMIT 1
`

type GetLatestCompletedAnalysisParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

type GetLatestCompletedAnalysisRow struct {
	ID          pgtype.UUID        `json:"id"`
	CommitSha   string             `json:"commit_sha"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
	TotalSuites int32              `json:"total_suites"`
	TotalTests  int32              `json:"total_tests"`
	Owner       string             `json:"owner"`
	Repo        string             `json:"repo"`
}

func (q *Queries) GetLatestCompletedAnalysis(ctx context.Context, arg GetLatestCompletedAnalysisParams) (GetLatestCompletedAnalysisRow, error) {
	row := q.db.QueryRow(ctx, getLatestCompletedAnalysis, arg.Host, arg.Owner, arg.Name)
	var i GetLatestCompletedAnalysisRow
	err := row.Scan(
		&i.ID,
		&i.CommitSha,
		&i.CompletedAt,
		&i.TotalSuites,
		&i.TotalTests,
		&i.Owner,
		&i.Repo,
	)
	return i, err
}

const getTestCasesBySuiteIDs = `-- name: GetTestCasesBySuiteIDs :many
SELECT
    tc.id,
    tc.suite_id,
    tc.name,
    tc.line_number,
    tc.status
FROM test_cases tc
WHERE tc.suite_id = ANY($1::uuid[])
ORDER BY tc.suite_id, tc.line_number
`

type GetTestCasesBySuiteIDsRow struct {
	ID         pgtype.UUID `json:"id"`
	SuiteID    pgtype.UUID `json:"suite_id"`
	Name       string      `json:"name"`
	LineNumber pgtype.Int4 `json:"line_number"`
	Status     TestStatus  `json:"status"`
}

func (q *Queries) GetTestCasesBySuiteIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]GetTestCasesBySuiteIDsRow, error) {
	rows, err := q.db.Query(ctx, getTestCasesBySuiteIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestCasesBySuiteIDsRow
	for rows.Next() {
		var i GetTestCasesBySuiteIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.SuiteID,
			&i.Name,
			&i.LineNumber,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestSuitesByAnalysisID = `-- name: GetTestSuitesByAnalysisID :many
SELECT
    ts.id,
    ts.file_path,
    ts.framework
FROM test_suites ts
WHERE ts.analysis_id = $1
ORDER BY ts.file_path
`

type GetTestSuitesByAnalysisIDRow struct {
	ID        pgtype.UUID `json:"id"`
	FilePath  string      `json:"file_path"`
	Framework pgtype.Text `json:"framework"`
}

func (q *Queries) GetTestSuitesByAnalysisID(ctx context.Context, analysisID pgtype.UUID) ([]GetTestSuitesByAnalysisIDRow, error) {
	rows, err := q.db.Query(ctx, getTestSuitesByAnalysisID, analysisID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestSuitesByAnalysisIDRow
	for rows.Next() {
		var i GetTestSuitesByAnalysisIDRow
		if err := rows.Scan(&i.ID, &i.FilePath, &i.Framework); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAnalysisFailed = `-- name: MarkAnalysisFailed :exec
UPDATE analyses
SET status = 'failed', error_message = $2
WHERE id = $1
`

type MarkAnalysisFailedParams struct {
	ID           pgtype.UUID `json:"id"`
	ErrorMessage pgtype.Text `json:"error_message"`
}

func (q *Queries) MarkAnalysisFailed(ctx context.Context, arg MarkAnalysisFailedParams) error {
	_, err := q.db.Exec(ctx, markAnalysisFailed, arg.ID, arg.ErrorMessage)
	return err
}

const upsertCodebase = `-- name: UpsertCodebase :one
INSERT INTO codebases (host, owner, name)
VALUES ($1, $2, $3)
ON CONFLICT (host, owner, name) DO UPDATE SET updated_at = now()
RETURNING id
`

type UpsertCodebaseParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

func (q *Queries) UpsertCodebase(ctx context.Context, arg UpsertCodebaseParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, upsertCodebase, arg.Host, arg.Owner, arg.Name)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}
