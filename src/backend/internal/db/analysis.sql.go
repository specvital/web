// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: analysis.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPendingAnalysis = `-- name: CreatePendingAnalysis :one
INSERT INTO analyses (codebase_id, commit_sha, status)
VALUES ($1, $2, 'pending')
RETURNING id
`

type CreatePendingAnalysisParams struct {
	CodebaseID pgtype.UUID `json:"codebase_id"`
	CommitSha  string      `json:"commit_sha"`
}

func (q *Queries) CreatePendingAnalysis(ctx context.Context, arg CreatePendingAnalysisParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createPendingAnalysis, arg.CodebaseID, arg.CommitSha)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getAnalysisStatus = `-- name: GetAnalysisStatus :one
SELECT
    a.id,
    a.status,
    a.error_message,
    a.created_at,
    a.completed_at
FROM analyses a
JOIN codebases c ON c.id = a.codebase_id
WHERE c.host = $1 AND c.owner = $2 AND c.name = $3
ORDER BY a.created_at DESC
LIMIT 1
`

type GetAnalysisStatusParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

type GetAnalysisStatusRow struct {
	ID           pgtype.UUID        `json:"id"`
	Status       AnalysisStatus     `json:"status"`
	ErrorMessage pgtype.Text        `json:"error_message"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) GetAnalysisStatus(ctx context.Context, arg GetAnalysisStatusParams) (GetAnalysisStatusRow, error) {
	row := q.db.QueryRow(ctx, getAnalysisStatus, arg.Host, arg.Owner, arg.Name)
	var i GetAnalysisStatusRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getCodebaseIDByOwnerRepo = `-- name: GetCodebaseIDByOwnerRepo :one
SELECT id
FROM codebases
WHERE host = $1 AND owner = $2 AND name = $3 AND is_stale = false
`

type GetCodebaseIDByOwnerRepoParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

func (q *Queries) GetCodebaseIDByOwnerRepo(ctx context.Context, arg GetCodebaseIDByOwnerRepoParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getCodebaseIDByOwnerRepo, arg.Host, arg.Owner, arg.Name)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getLatestCompletedAnalysis = `-- name: GetLatestCompletedAnalysis :one
SELECT
    a.id,
    a.commit_sha,
    a.branch_name,
    a.committed_at,
    a.completed_at,
    a.total_suites,
    a.total_tests,
    c.owner,
    c.name as repo
FROM analyses a
JOIN codebases c ON c.id = a.codebase_id
WHERE c.host = $1 AND c.owner = $2 AND c.name = $3
  AND a.status = 'completed'
ORDER BY a.created_at DESC
LIMIT 1
`

type GetLatestCompletedAnalysisParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

type GetLatestCompletedAnalysisRow struct {
	ID          pgtype.UUID        `json:"id"`
	CommitSha   string             `json:"commit_sha"`
	BranchName  pgtype.Text        `json:"branch_name"`
	CommittedAt pgtype.Timestamptz `json:"committed_at"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
	TotalSuites int32              `json:"total_suites"`
	TotalTests  int32              `json:"total_tests"`
	Owner       string             `json:"owner"`
	Repo        string             `json:"repo"`
}

func (q *Queries) GetLatestCompletedAnalysis(ctx context.Context, arg GetLatestCompletedAnalysisParams) (GetLatestCompletedAnalysisRow, error) {
	row := q.db.QueryRow(ctx, getLatestCompletedAnalysis, arg.Host, arg.Owner, arg.Name)
	var i GetLatestCompletedAnalysisRow
	err := row.Scan(
		&i.ID,
		&i.CommitSha,
		&i.BranchName,
		&i.CommittedAt,
		&i.CompletedAt,
		&i.TotalSuites,
		&i.TotalTests,
		&i.Owner,
		&i.Repo,
	)
	return i, err
}

const getPreviousAnalysis = `-- name: GetPreviousAnalysis :one
SELECT
    id,
    commit_sha,
    completed_at,
    total_tests
FROM analyses
WHERE codebase_id = $1
  AND status = 'completed'
  AND id != $2
ORDER BY created_at DESC
LIMIT 1
`

type GetPreviousAnalysisParams struct {
	CodebaseID pgtype.UUID `json:"codebase_id"`
	ID         pgtype.UUID `json:"id"`
}

type GetPreviousAnalysisRow struct {
	ID          pgtype.UUID        `json:"id"`
	CommitSha   string             `json:"commit_sha"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
	TotalTests  int32              `json:"total_tests"`
}

func (q *Queries) GetPreviousAnalysis(ctx context.Context, arg GetPreviousAnalysisParams) (GetPreviousAnalysisRow, error) {
	row := q.db.QueryRow(ctx, getPreviousAnalysis, arg.CodebaseID, arg.ID)
	var i GetPreviousAnalysisRow
	err := row.Scan(
		&i.ID,
		&i.CommitSha,
		&i.CompletedAt,
		&i.TotalTests,
	)
	return i, err
}

const getRecentRepositories = `-- name: GetRecentRepositories :many
SELECT
    c.id AS codebase_id,
    c.owner,
    c.name,
    c.last_viewed_at,
    a.id AS analysis_id,
    a.commit_sha,
    a.completed_at AS analyzed_at,
    a.total_tests,
    EXISTS(
        SELECT 1 FROM user_analysis_history uah
        WHERE uah.analysis_id = a.id AND uah.user_id = $1::uuid
    ) AS is_analyzed_by_me
FROM codebases c
LEFT JOIN LATERAL (
    SELECT id, commit_sha, completed_at, total_tests
    FROM analyses
    WHERE codebase_id = c.id AND status = 'completed'
    ORDER BY created_at DESC
    LIMIT 1
) a ON true
WHERE c.last_viewed_at IS NOT NULL AND c.is_stale = false
ORDER BY c.last_viewed_at DESC
LIMIT $2
`

type GetRecentRepositoriesParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	PageLimit int32       `json:"page_limit"`
}

type GetRecentRepositoriesRow struct {
	CodebaseID     pgtype.UUID        `json:"codebase_id"`
	Owner          string             `json:"owner"`
	Name           string             `json:"name"`
	LastViewedAt   pgtype.Timestamptz `json:"last_viewed_at"`
	AnalysisID     pgtype.UUID        `json:"analysis_id"`
	CommitSha      string             `json:"commit_sha"`
	AnalyzedAt     pgtype.Timestamptz `json:"analyzed_at"`
	TotalTests     int32              `json:"total_tests"`
	IsAnalyzedByMe bool               `json:"is_analyzed_by_me"`
}

func (q *Queries) GetRecentRepositories(ctx context.Context, arg GetRecentRepositoriesParams) ([]GetRecentRepositoriesRow, error) {
	rows, err := q.db.Query(ctx, getRecentRepositories, arg.UserID, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentRepositoriesRow
	for rows.Next() {
		var i GetRecentRepositoriesRow
		if err := rows.Scan(
			&i.CodebaseID,
			&i.Owner,
			&i.Name,
			&i.LastViewedAt,
			&i.AnalysisID,
			&i.CommitSha,
			&i.AnalyzedAt,
			&i.TotalTests,
			&i.IsAnalyzedByMe,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepositoryStats = `-- name: GetRepositoryStats :one
SELECT
    COUNT(DISTINCT c.id) AS total_repositories,
    COALESCE(SUM(a.total_tests), 0)::bigint AS total_tests
FROM codebases c
LEFT JOIN LATERAL (
    SELECT total_tests
    FROM analyses
    WHERE codebase_id = c.id AND status = 'completed'
    ORDER BY created_at DESC
    LIMIT 1
) a ON true
WHERE c.last_viewed_at IS NOT NULL AND c.is_stale = false
`

type GetRepositoryStatsRow struct {
	TotalRepositories int64 `json:"total_repositories"`
	TotalTests        int64 `json:"total_tests"`
}

func (q *Queries) GetRepositoryStats(ctx context.Context) (GetRepositoryStatsRow, error) {
	row := q.db.QueryRow(ctx, getRepositoryStats)
	var i GetRepositoryStatsRow
	err := row.Scan(&i.TotalRepositories, &i.TotalTests)
	return i, err
}

const getTestCasesBySuiteIDs = `-- name: GetTestCasesBySuiteIDs :many
SELECT
    tc.id,
    tc.suite_id,
    tc.name,
    tc.line_number,
    tc.status
FROM test_cases tc
WHERE tc.suite_id = ANY($1::uuid[])
ORDER BY tc.suite_id, tc.line_number
`

type GetTestCasesBySuiteIDsRow struct {
	ID         pgtype.UUID `json:"id"`
	SuiteID    pgtype.UUID `json:"suite_id"`
	Name       string      `json:"name"`
	LineNumber pgtype.Int4 `json:"line_number"`
	Status     TestStatus  `json:"status"`
}

func (q *Queries) GetTestCasesBySuiteIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]GetTestCasesBySuiteIDsRow, error) {
	rows, err := q.db.Query(ctx, getTestCasesBySuiteIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestCasesBySuiteIDsRow
	for rows.Next() {
		var i GetTestCasesBySuiteIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.SuiteID,
			&i.Name,
			&i.LineNumber,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestSuitesByAnalysisID = `-- name: GetTestSuitesByAnalysisID :many
SELECT
    ts.id,
    ts.file_path,
    ts.framework,
    ts.name
FROM test_suites ts
WHERE ts.analysis_id = $1
ORDER BY ts.file_path, ts.depth, ts.line_number
`

type GetTestSuitesByAnalysisIDRow struct {
	ID        pgtype.UUID `json:"id"`
	FilePath  string      `json:"file_path"`
	Framework pgtype.Text `json:"framework"`
	Name      string      `json:"name"`
}

func (q *Queries) GetTestSuitesByAnalysisID(ctx context.Context, analysisID pgtype.UUID) ([]GetTestSuitesByAnalysisIDRow, error) {
	rows, err := q.db.Query(ctx, getTestSuitesByAnalysisID, analysisID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestSuitesByAnalysisIDRow
	for rows.Next() {
		var i GetTestSuitesByAnalysisIDRow
		if err := rows.Scan(
			&i.ID,
			&i.FilePath,
			&i.Framework,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAnalysisFailed = `-- name: MarkAnalysisFailed :exec
UPDATE analyses
SET status = 'failed', error_message = $2
WHERE id = $1
`

type MarkAnalysisFailedParams struct {
	ID           pgtype.UUID `json:"id"`
	ErrorMessage pgtype.Text `json:"error_message"`
}

func (q *Queries) MarkAnalysisFailed(ctx context.Context, arg MarkAnalysisFailedParams) error {
	_, err := q.db.Exec(ctx, markAnalysisFailed, arg.ID, arg.ErrorMessage)
	return err
}

const updateCodebaseLastViewed = `-- name: UpdateCodebaseLastViewed :exec
UPDATE codebases
SET last_viewed_at = now()
WHERE host = $1 AND owner = $2 AND name = $3
`

type UpdateCodebaseLastViewedParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

func (q *Queries) UpdateCodebaseLastViewed(ctx context.Context, arg UpdateCodebaseLastViewedParams) error {
	_, err := q.db.Exec(ctx, updateCodebaseLastViewed, arg.Host, arg.Owner, arg.Name)
	return err
}

const upsertCodebase = `-- name: UpsertCodebase :one
INSERT INTO codebases (host, owner, name)
VALUES ($1, $2, $3)
ON CONFLICT (host, owner, name) DO UPDATE SET updated_at = now()
RETURNING id
`

type UpsertCodebaseParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

func (q *Queries) UpsertCodebase(ctx context.Context, arg UpsertCodebaseParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, upsertCodebase, arg.Host, arg.Owner, arg.Name)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}
