// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: subscription.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUserSubscription = `-- name: CreateUserSubscription :one
INSERT INTO user_subscriptions (user_id, plan_id, current_period_start, current_period_end)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, plan_id, status, current_period_start, current_period_end, created_at
`

type CreateUserSubscriptionParams struct {
	UserID             pgtype.UUID        `json:"user_id"`
	PlanID             pgtype.UUID        `json:"plan_id"`
	CurrentPeriodStart pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd   pgtype.Timestamptz `json:"current_period_end"`
}

type CreateUserSubscriptionRow struct {
	ID                 pgtype.UUID        `json:"id"`
	UserID             pgtype.UUID        `json:"user_id"`
	PlanID             pgtype.UUID        `json:"plan_id"`
	Status             SubscriptionStatus `json:"status"`
	CurrentPeriodStart pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd   pgtype.Timestamptz `json:"current_period_end"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateUserSubscription(ctx context.Context, arg CreateUserSubscriptionParams) (CreateUserSubscriptionRow, error) {
	row := q.db.QueryRow(ctx, createUserSubscription,
		arg.UserID,
		arg.PlanID,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
	)
	var i CreateUserSubscriptionRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlanID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CreatedAt,
	)
	return i, err
}

const getActiveSubscriptionWithPlan = `-- name: GetActiveSubscriptionWithPlan :one
SELECT
    us.id,
    us.user_id,
    us.plan_id,
    us.status,
    us.current_period_start,
    us.current_period_end,
    us.canceled_at,
    us.created_at,
    us.updated_at,
    sp.tier AS plan_tier,
    sp.specview_monthly_limit AS plan_specview_monthly_limit,
    sp.analysis_monthly_limit AS plan_analysis_monthly_limit,
    sp.retention_days AS plan_retention_days
FROM user_subscriptions us
JOIN subscription_plans sp ON us.plan_id = sp.id
WHERE us.user_id = $1 AND us.status = 'active'
`

type GetActiveSubscriptionWithPlanRow struct {
	ID                       pgtype.UUID        `json:"id"`
	UserID                   pgtype.UUID        `json:"user_id"`
	PlanID                   pgtype.UUID        `json:"plan_id"`
	Status                   SubscriptionStatus `json:"status"`
	CurrentPeriodStart       pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd         pgtype.Timestamptz `json:"current_period_end"`
	CanceledAt               pgtype.Timestamptz `json:"canceled_at"`
	CreatedAt                pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                pgtype.Timestamptz `json:"updated_at"`
	PlanTier                 PlanTier           `json:"plan_tier"`
	PlanSpecviewMonthlyLimit pgtype.Int4        `json:"plan_specview_monthly_limit"`
	PlanAnalysisMonthlyLimit pgtype.Int4        `json:"plan_analysis_monthly_limit"`
	PlanRetentionDays        pgtype.Int4        `json:"plan_retention_days"`
}

func (q *Queries) GetActiveSubscriptionWithPlan(ctx context.Context, userID pgtype.UUID) (GetActiveSubscriptionWithPlanRow, error) {
	row := q.db.QueryRow(ctx, getActiveSubscriptionWithPlan, userID)
	var i GetActiveSubscriptionWithPlanRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlanID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CanceledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PlanTier,
		&i.PlanSpecviewMonthlyLimit,
		&i.PlanAnalysisMonthlyLimit,
		&i.PlanRetentionDays,
	)
	return i, err
}

const getAllPlans = `-- name: GetAllPlans :many
SELECT
    id,
    tier,
    specview_monthly_limit,
    analysis_monthly_limit,
    retention_days,
    created_at
FROM subscription_plans
ORDER BY
    CASE tier
        WHEN 'free' THEN 1
        WHEN 'pro' THEN 2
        WHEN 'pro_plus' THEN 3
        WHEN 'enterprise' THEN 4
    END
`

func (q *Queries) GetAllPlans(ctx context.Context) ([]SubscriptionPlan, error) {
	rows, err := q.db.Query(ctx, getAllPlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubscriptionPlan
	for rows.Next() {
		var i SubscriptionPlan
		if err := rows.Scan(
			&i.ID,
			&i.Tier,
			&i.SpecviewMonthlyLimit,
			&i.AnalysisMonthlyLimit,
			&i.RetentionDays,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlanByTier = `-- name: GetPlanByTier :one
SELECT
    id,
    tier,
    specview_monthly_limit,
    analysis_monthly_limit,
    retention_days,
    created_at
FROM subscription_plans
WHERE tier = $1
`

func (q *Queries) GetPlanByTier(ctx context.Context, tier PlanTier) (SubscriptionPlan, error) {
	row := q.db.QueryRow(ctx, getPlanByTier, tier)
	var i SubscriptionPlan
	err := row.Scan(
		&i.ID,
		&i.Tier,
		&i.SpecviewMonthlyLimit,
		&i.AnalysisMonthlyLimit,
		&i.RetentionDays,
		&i.CreatedAt,
	)
	return i, err
}

const getUsersWithoutActiveSubscription = `-- name: GetUsersWithoutActiveSubscription :many
SELECT id
FROM users
WHERE id NOT IN (
    SELECT user_id FROM user_subscriptions WHERE status = 'active'
)
`

func (q *Queries) GetUsersWithoutActiveSubscription(ctx context.Context) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getUsersWithoutActiveSubscription)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
