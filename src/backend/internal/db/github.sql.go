// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: github.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteOrgGitHubRepositories = `-- name: DeleteOrgGitHubRepositories :exec
DELETE FROM user_github_repositories
WHERE user_id = $1 AND org_id = $2
`

type DeleteOrgGitHubRepositoriesParams struct {
	UserID pgtype.UUID `json:"user_id"`
	OrgID  pgtype.UUID `json:"org_id"`
}

func (q *Queries) DeleteOrgGitHubRepositories(ctx context.Context, arg DeleteOrgGitHubRepositoriesParams) error {
	_, err := q.db.Exec(ctx, deleteOrgGitHubRepositories, arg.UserID, arg.OrgID)
	return err
}

const deleteUserGitHubRepositories = `-- name: DeleteUserGitHubRepositories :exec
DELETE FROM user_github_repositories
WHERE user_id = $1 AND source_type = 'personal'
`

func (q *Queries) DeleteUserGitHubRepositories(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserGitHubRepositories, userID)
	return err
}

const deleteUserOrgMemberships = `-- name: DeleteUserOrgMemberships :exec
DELETE FROM user_github_org_memberships WHERE user_id = $1
`

func (q *Queries) DeleteUserOrgMemberships(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserOrgMemberships, userID)
	return err
}

const getGitHubOrganizationByLogin = `-- name: GetGitHubOrganizationByLogin :one
SELECT id, github_org_id FROM github_organizations WHERE login = $1
`

type GetGitHubOrganizationByLoginRow struct {
	ID          pgtype.UUID `json:"id"`
	GithubOrgID int64       `json:"github_org_id"`
}

func (q *Queries) GetGitHubOrganizationByLogin(ctx context.Context, login string) (GetGitHubOrganizationByLoginRow, error) {
	row := q.db.QueryRow(ctx, getGitHubOrganizationByLogin, login)
	var i GetGitHubOrganizationByLoginRow
	err := row.Scan(&i.ID, &i.GithubOrgID)
	return i, err
}

const getOrgGitHubRepositories = `-- name: GetOrgGitHubRepositories :many
SELECT
    github_repo_id, name, full_name, html_url, description,
    default_branch, language, visibility, is_private, archived,
    disabled, fork, stargazers_count, pushed_at
FROM user_github_repositories
WHERE user_id = $1 AND org_id = $2
ORDER BY pushed_at DESC NULLS LAST, updated_at DESC
`

type GetOrgGitHubRepositoriesParams struct {
	UserID pgtype.UUID `json:"user_id"`
	OrgID  pgtype.UUID `json:"org_id"`
}

type GetOrgGitHubRepositoriesRow struct {
	GithubRepoID    int64              `json:"github_repo_id"`
	Name            string             `json:"name"`
	FullName        string             `json:"full_name"`
	HtmlUrl         string             `json:"html_url"`
	Description     pgtype.Text        `json:"description"`
	DefaultBranch   pgtype.Text        `json:"default_branch"`
	Language        pgtype.Text        `json:"language"`
	Visibility      string             `json:"visibility"`
	IsPrivate       bool               `json:"is_private"`
	Archived        bool               `json:"archived"`
	Disabled        bool               `json:"disabled"`
	Fork            bool               `json:"fork"`
	StargazersCount int32              `json:"stargazers_count"`
	PushedAt        pgtype.Timestamptz `json:"pushed_at"`
}

func (q *Queries) GetOrgGitHubRepositories(ctx context.Context, arg GetOrgGitHubRepositoriesParams) ([]GetOrgGitHubRepositoriesRow, error) {
	rows, err := q.db.Query(ctx, getOrgGitHubRepositories, arg.UserID, arg.OrgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrgGitHubRepositoriesRow
	for rows.Next() {
		var i GetOrgGitHubRepositoriesRow
		if err := rows.Scan(
			&i.GithubRepoID,
			&i.Name,
			&i.FullName,
			&i.HtmlUrl,
			&i.Description,
			&i.DefaultBranch,
			&i.Language,
			&i.Visibility,
			&i.IsPrivate,
			&i.Archived,
			&i.Disabled,
			&i.Fork,
			&i.StargazersCount,
			&i.PushedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserGitHubOrganizations = `-- name: GetUserGitHubOrganizations :many
SELECT
    go.id AS org_id,
    go.github_org_id,
    go.login,
    go.avatar_url,
    go.html_url,
    go.description,
    m.role
FROM github_organizations go
JOIN user_github_org_memberships m ON go.id = m.org_id
WHERE m.user_id = $1
ORDER BY go.login
`

type GetUserGitHubOrganizationsRow struct {
	OrgID       pgtype.UUID `json:"org_id"`
	GithubOrgID int64       `json:"github_org_id"`
	Login       string      `json:"login"`
	AvatarUrl   pgtype.Text `json:"avatar_url"`
	HtmlUrl     pgtype.Text `json:"html_url"`
	Description pgtype.Text `json:"description"`
	Role        pgtype.Text `json:"role"`
}

func (q *Queries) GetUserGitHubOrganizations(ctx context.Context, userID pgtype.UUID) ([]GetUserGitHubOrganizationsRow, error) {
	rows, err := q.db.Query(ctx, getUserGitHubOrganizations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserGitHubOrganizationsRow
	for rows.Next() {
		var i GetUserGitHubOrganizationsRow
		if err := rows.Scan(
			&i.OrgID,
			&i.GithubOrgID,
			&i.Login,
			&i.AvatarUrl,
			&i.HtmlUrl,
			&i.Description,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserGitHubRepositories = `-- name: GetUserGitHubRepositories :many
SELECT
    github_repo_id, name, full_name, html_url, description,
    default_branch, language, visibility, is_private, archived,
    disabled, fork, stargazers_count, pushed_at
FROM user_github_repositories
WHERE user_id = $1 AND source_type = 'personal'
ORDER BY pushed_at DESC NULLS LAST, updated_at DESC
`

type GetUserGitHubRepositoriesRow struct {
	GithubRepoID    int64              `json:"github_repo_id"`
	Name            string             `json:"name"`
	FullName        string             `json:"full_name"`
	HtmlUrl         string             `json:"html_url"`
	Description     pgtype.Text        `json:"description"`
	DefaultBranch   pgtype.Text        `json:"default_branch"`
	Language        pgtype.Text        `json:"language"`
	Visibility      string             `json:"visibility"`
	IsPrivate       bool               `json:"is_private"`
	Archived        bool               `json:"archived"`
	Disabled        bool               `json:"disabled"`
	Fork            bool               `json:"fork"`
	StargazersCount int32              `json:"stargazers_count"`
	PushedAt        pgtype.Timestamptz `json:"pushed_at"`
}

func (q *Queries) GetUserGitHubRepositories(ctx context.Context, userID pgtype.UUID) ([]GetUserGitHubRepositoriesRow, error) {
	rows, err := q.db.Query(ctx, getUserGitHubRepositories, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserGitHubRepositoriesRow
	for rows.Next() {
		var i GetUserGitHubRepositoriesRow
		if err := rows.Scan(
			&i.GithubRepoID,
			&i.Name,
			&i.FullName,
			&i.HtmlUrl,
			&i.Description,
			&i.DefaultBranch,
			&i.Language,
			&i.Visibility,
			&i.IsPrivate,
			&i.Archived,
			&i.Disabled,
			&i.Fork,
			&i.StargazersCount,
			&i.PushedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasOrgGitHubRepositories = `-- name: HasOrgGitHubRepositories :one
SELECT EXISTS(
    SELECT 1 FROM user_github_repositories
    WHERE user_id = $1 AND org_id = $2
) AS has_repos
`

type HasOrgGitHubRepositoriesParams struct {
	UserID pgtype.UUID `json:"user_id"`
	OrgID  pgtype.UUID `json:"org_id"`
}

func (q *Queries) HasOrgGitHubRepositories(ctx context.Context, arg HasOrgGitHubRepositoriesParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasOrgGitHubRepositories, arg.UserID, arg.OrgID)
	var has_repos bool
	err := row.Scan(&has_repos)
	return has_repos, err
}

const hasUserGitHubRepositories = `-- name: HasUserGitHubRepositories :one
SELECT EXISTS(
    SELECT 1 FROM user_github_repositories
    WHERE user_id = $1 AND source_type = 'personal'
) AS has_repos
`

func (q *Queries) HasUserGitHubRepositories(ctx context.Context, userID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, hasUserGitHubRepositories, userID)
	var has_repos bool
	err := row.Scan(&has_repos)
	return has_repos, err
}

const hasUserOrgMemberships = `-- name: HasUserOrgMemberships :one
SELECT EXISTS(
    SELECT 1 FROM user_github_org_memberships WHERE user_id = $1
) AS has_orgs
`

func (q *Queries) HasUserOrgMemberships(ctx context.Context, userID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, hasUserOrgMemberships, userID)
	var has_orgs bool
	err := row.Scan(&has_orgs)
	return has_orgs, err
}

const upsertGitHubOrganization = `-- name: UpsertGitHubOrganization :one

INSERT INTO github_organizations (
    github_org_id, login, avatar_url, html_url, description, updated_at
) VALUES ($1, $2, $3, $4, $5, now())
ON CONFLICT (github_org_id) DO UPDATE SET
    login = EXCLUDED.login,
    avatar_url = EXCLUDED.avatar_url,
    html_url = EXCLUDED.html_url,
    description = EXCLUDED.description,
    updated_at = now()
RETURNING id
`

type UpsertGitHubOrganizationParams struct {
	GithubOrgID int64       `json:"github_org_id"`
	Login       string      `json:"login"`
	AvatarUrl   pgtype.Text `json:"avatar_url"`
	HtmlUrl     pgtype.Text `json:"html_url"`
	Description pgtype.Text `json:"description"`
}

// =============================================================================
// GitHub Organizations (Global)
// =============================================================================
func (q *Queries) UpsertGitHubOrganization(ctx context.Context, arg UpsertGitHubOrganizationParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, upsertGitHubOrganization,
		arg.GithubOrgID,
		arg.Login,
		arg.AvatarUrl,
		arg.HtmlUrl,
		arg.Description,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const upsertOrgGitHubRepository = `-- name: UpsertOrgGitHubRepository :exec

INSERT INTO user_github_repositories (
    user_id, github_repo_id, name, full_name, html_url,
    description, default_branch, language, visibility, is_private,
    archived, disabled, fork, stargazers_count, pushed_at,
    source_type, org_id, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15,
    'organization', $16, now()
)
ON CONFLICT (user_id, github_repo_id) DO UPDATE SET
    name = EXCLUDED.name,
    full_name = EXCLUDED.full_name,
    html_url = EXCLUDED.html_url,
    description = EXCLUDED.description,
    default_branch = EXCLUDED.default_branch,
    language = EXCLUDED.language,
    visibility = EXCLUDED.visibility,
    is_private = EXCLUDED.is_private,
    archived = EXCLUDED.archived,
    disabled = EXCLUDED.disabled,
    fork = EXCLUDED.fork,
    stargazers_count = EXCLUDED.stargazers_count,
    pushed_at = EXCLUDED.pushed_at,
    source_type = 'organization',
    org_id = EXCLUDED.org_id,
    updated_at = now()
`

type UpsertOrgGitHubRepositoryParams struct {
	UserID          pgtype.UUID        `json:"user_id"`
	GithubRepoID    int64              `json:"github_repo_id"`
	Name            string             `json:"name"`
	FullName        string             `json:"full_name"`
	HtmlUrl         string             `json:"html_url"`
	Description     pgtype.Text        `json:"description"`
	DefaultBranch   pgtype.Text        `json:"default_branch"`
	Language        pgtype.Text        `json:"language"`
	Visibility      string             `json:"visibility"`
	IsPrivate       bool               `json:"is_private"`
	Archived        bool               `json:"archived"`
	Disabled        bool               `json:"disabled"`
	Fork            bool               `json:"fork"`
	StargazersCount int32              `json:"stargazers_count"`
	PushedAt        pgtype.Timestamptz `json:"pushed_at"`
	OrgID           pgtype.UUID        `json:"org_id"`
}

// =============================================================================
// Organization Repositories
// =============================================================================
func (q *Queries) UpsertOrgGitHubRepository(ctx context.Context, arg UpsertOrgGitHubRepositoryParams) error {
	_, err := q.db.Exec(ctx, upsertOrgGitHubRepository,
		arg.UserID,
		arg.GithubRepoID,
		arg.Name,
		arg.FullName,
		arg.HtmlUrl,
		arg.Description,
		arg.DefaultBranch,
		arg.Language,
		arg.Visibility,
		arg.IsPrivate,
		arg.Archived,
		arg.Disabled,
		arg.Fork,
		arg.StargazersCount,
		arg.PushedAt,
		arg.OrgID,
	)
	return err
}

const upsertUserGitHubRepository = `-- name: UpsertUserGitHubRepository :exec

INSERT INTO user_github_repositories (
    user_id, github_repo_id, name, full_name, html_url,
    description, default_branch, language, visibility, is_private,
    archived, disabled, fork, stargazers_count, pushed_at,
    source_type, org_id, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15,
    'personal', NULL, now()
)
ON CONFLICT (user_id, github_repo_id) DO UPDATE SET
    name = EXCLUDED.name,
    full_name = EXCLUDED.full_name,
    html_url = EXCLUDED.html_url,
    description = EXCLUDED.description,
    default_branch = EXCLUDED.default_branch,
    language = EXCLUDED.language,
    visibility = EXCLUDED.visibility,
    is_private = EXCLUDED.is_private,
    archived = EXCLUDED.archived,
    disabled = EXCLUDED.disabled,
    fork = EXCLUDED.fork,
    stargazers_count = EXCLUDED.stargazers_count,
    pushed_at = EXCLUDED.pushed_at,
    source_type = 'personal',
    org_id = NULL,
    updated_at = now()
`

type UpsertUserGitHubRepositoryParams struct {
	UserID          pgtype.UUID        `json:"user_id"`
	GithubRepoID    int64              `json:"github_repo_id"`
	Name            string             `json:"name"`
	FullName        string             `json:"full_name"`
	HtmlUrl         string             `json:"html_url"`
	Description     pgtype.Text        `json:"description"`
	DefaultBranch   pgtype.Text        `json:"default_branch"`
	Language        pgtype.Text        `json:"language"`
	Visibility      string             `json:"visibility"`
	IsPrivate       bool               `json:"is_private"`
	Archived        bool               `json:"archived"`
	Disabled        bool               `json:"disabled"`
	Fork            bool               `json:"fork"`
	StargazersCount int32              `json:"stargazers_count"`
	PushedAt        pgtype.Timestamptz `json:"pushed_at"`
}

// =============================================================================
// User Personal Repositories
// =============================================================================
func (q *Queries) UpsertUserGitHubRepository(ctx context.Context, arg UpsertUserGitHubRepositoryParams) error {
	_, err := q.db.Exec(ctx, upsertUserGitHubRepository,
		arg.UserID,
		arg.GithubRepoID,
		arg.Name,
		arg.FullName,
		arg.HtmlUrl,
		arg.Description,
		arg.DefaultBranch,
		arg.Language,
		arg.Visibility,
		arg.IsPrivate,
		arg.Archived,
		arg.Disabled,
		arg.Fork,
		arg.StargazersCount,
		arg.PushedAt,
	)
	return err
}

const upsertUserOrgMembership = `-- name: UpsertUserOrgMembership :exec

INSERT INTO user_github_org_memberships (user_id, org_id, role, updated_at)
VALUES ($1, $2, $3, now())
ON CONFLICT (user_id, org_id) DO UPDATE SET
    role = EXCLUDED.role,
    updated_at = now()
`

type UpsertUserOrgMembershipParams struct {
	UserID pgtype.UUID `json:"user_id"`
	OrgID  pgtype.UUID `json:"org_id"`
	Role   pgtype.Text `json:"role"`
}

// =============================================================================
// User Organization Memberships
// =============================================================================
func (q *Queries) UpsertUserOrgMembership(ctx context.Context, arg UpsertUserOrgMembershipParams) error {
	_, err := q.db.Exec(ctx, upsertUserOrgMembership, arg.UserID, arg.OrgID, arg.Role)
	return err
}
