// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: spec_document.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkAnalysisExists = `-- name: CheckAnalysisExists :one
SELECT EXISTS(
    SELECT 1 FROM analyses WHERE id = $1 AND status = 'completed'
) AS exists
`

func (q *Queries) CheckAnalysisExists(ctx context.Context, id pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkAnalysisExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkSpecDocumentExistsByLanguage = `-- name: CheckSpecDocumentExistsByLanguage :one
SELECT EXISTS(
    SELECT 1 FROM spec_documents WHERE analysis_id = $1 AND language = $2
) AS exists
`

type CheckSpecDocumentExistsByLanguageParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	Language   string      `json:"language"`
}

func (q *Queries) CheckSpecDocumentExistsByLanguage(ctx context.Context, arg CheckSpecDocumentExistsByLanguageParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkSpecDocumentExistsByLanguage, arg.AnalysisID, arg.Language)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const deleteSpecDocumentByLanguage = `-- name: DeleteSpecDocumentByLanguage :exec
DELETE FROM spec_documents
WHERE analysis_id = $1 AND language = $2
`

type DeleteSpecDocumentByLanguageParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	Language   string      `json:"language"`
}

func (q *Queries) DeleteSpecDocumentByLanguage(ctx context.Context, arg DeleteSpecDocumentByLanguageParams) error {
	_, err := q.db.Exec(ctx, deleteSpecDocumentByLanguage, arg.AnalysisID, arg.Language)
	return err
}

const getSpecBehaviorSourceInfo = `-- name: GetSpecBehaviorSourceInfo :many
SELECT
    b.id AS behavior_id,
    tc.line_number,
    tc.status::text,
    tf.file_path,
    tf.framework
FROM spec_behaviors b
JOIN test_cases tc ON tc.id = b.source_test_case_id
JOIN test_suites ts ON ts.id = tc.suite_id
JOIN test_files tf ON tf.id = ts.file_id
WHERE b.id = ANY($1::uuid[])
`

type GetSpecBehaviorSourceInfoRow struct {
	BehaviorID pgtype.UUID `json:"behavior_id"`
	LineNumber pgtype.Int4 `json:"line_number"`
	TcStatus   string      `json:"tc_status"`
	FilePath   string      `json:"file_path"`
	Framework  pgtype.Text `json:"framework"`
}

func (q *Queries) GetSpecBehaviorSourceInfo(ctx context.Context, dollar_1 []pgtype.UUID) ([]GetSpecBehaviorSourceInfoRow, error) {
	rows, err := q.db.Query(ctx, getSpecBehaviorSourceInfo, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpecBehaviorSourceInfoRow
	for rows.Next() {
		var i GetSpecBehaviorSourceInfoRow
		if err := rows.Scan(
			&i.BehaviorID,
			&i.LineNumber,
			&i.TcStatus,
			&i.FilePath,
			&i.Framework,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecBehaviorsByFeatureIDs = `-- name: GetSpecBehaviorsByFeatureIDs :many
SELECT
    b.id,
    b.feature_id,
    b.original_name,
    b.converted_description,
    b.sort_order,
    b.source_test_case_id
FROM spec_behaviors b
WHERE b.feature_id = ANY($1::uuid[])
ORDER BY b.feature_id, b.sort_order
`

type GetSpecBehaviorsByFeatureIDsRow struct {
	ID                   pgtype.UUID `json:"id"`
	FeatureID            pgtype.UUID `json:"feature_id"`
	OriginalName         string      `json:"original_name"`
	ConvertedDescription string      `json:"converted_description"`
	SortOrder            int32       `json:"sort_order"`
	SourceTestCaseID     pgtype.UUID `json:"source_test_case_id"`
}

func (q *Queries) GetSpecBehaviorsByFeatureIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]GetSpecBehaviorsByFeatureIDsRow, error) {
	rows, err := q.db.Query(ctx, getSpecBehaviorsByFeatureIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpecBehaviorsByFeatureIDsRow
	for rows.Next() {
		var i GetSpecBehaviorsByFeatureIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.FeatureID,
			&i.OriginalName,
			&i.ConvertedDescription,
			&i.SortOrder,
			&i.SourceTestCaseID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecDocumentByAnalysisID = `-- name: GetSpecDocumentByAnalysisID :one
SELECT
    sd.id,
    sd.analysis_id,
    sd.language,
    sd.executive_summary,
    sd.model_id,
    sd.created_at
FROM spec_documents sd
WHERE sd.analysis_id = $1
ORDER BY sd.created_at DESC
LIMIT 1
`

type GetSpecDocumentByAnalysisIDRow struct {
	ID               pgtype.UUID        `json:"id"`
	AnalysisID       pgtype.UUID        `json:"analysis_id"`
	Language         string             `json:"language"`
	ExecutiveSummary pgtype.Text        `json:"executive_summary"`
	ModelID          string             `json:"model_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetSpecDocumentByAnalysisID(ctx context.Context, analysisID pgtype.UUID) (GetSpecDocumentByAnalysisIDRow, error) {
	row := q.db.QueryRow(ctx, getSpecDocumentByAnalysisID, analysisID)
	var i GetSpecDocumentByAnalysisIDRow
	err := row.Scan(
		&i.ID,
		&i.AnalysisID,
		&i.Language,
		&i.ExecutiveSummary,
		&i.ModelID,
		&i.CreatedAt,
	)
	return i, err
}

const getSpecDocumentByAnalysisIDAndLanguage = `-- name: GetSpecDocumentByAnalysisIDAndLanguage :one
SELECT
    sd.id,
    sd.analysis_id,
    sd.language,
    sd.executive_summary,
    sd.model_id,
    sd.created_at
FROM spec_documents sd
WHERE sd.analysis_id = $1 AND sd.language = $2
ORDER BY sd.created_at DESC
LIMIT 1
`

type GetSpecDocumentByAnalysisIDAndLanguageParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	Language   string      `json:"language"`
}

type GetSpecDocumentByAnalysisIDAndLanguageRow struct {
	ID               pgtype.UUID        `json:"id"`
	AnalysisID       pgtype.UUID        `json:"analysis_id"`
	Language         string             `json:"language"`
	ExecutiveSummary pgtype.Text        `json:"executive_summary"`
	ModelID          string             `json:"model_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetSpecDocumentByAnalysisIDAndLanguage(ctx context.Context, arg GetSpecDocumentByAnalysisIDAndLanguageParams) (GetSpecDocumentByAnalysisIDAndLanguageRow, error) {
	row := q.db.QueryRow(ctx, getSpecDocumentByAnalysisIDAndLanguage, arg.AnalysisID, arg.Language)
	var i GetSpecDocumentByAnalysisIDAndLanguageRow
	err := row.Scan(
		&i.ID,
		&i.AnalysisID,
		&i.Language,
		&i.ExecutiveSummary,
		&i.ModelID,
		&i.CreatedAt,
	)
	return i, err
}

const getSpecDomainsByDocumentID = `-- name: GetSpecDomainsByDocumentID :many
SELECT
    d.id,
    d.name,
    d.description,
    d.sort_order,
    d.classification_confidence
FROM spec_domains d
WHERE d.document_id = $1
ORDER BY d.sort_order, d.name
`

type GetSpecDomainsByDocumentIDRow struct {
	ID                       pgtype.UUID    `json:"id"`
	Name                     string         `json:"name"`
	Description              pgtype.Text    `json:"description"`
	SortOrder                int32          `json:"sort_order"`
	ClassificationConfidence pgtype.Numeric `json:"classification_confidence"`
}

func (q *Queries) GetSpecDomainsByDocumentID(ctx context.Context, documentID pgtype.UUID) ([]GetSpecDomainsByDocumentIDRow, error) {
	rows, err := q.db.Query(ctx, getSpecDomainsByDocumentID, documentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpecDomainsByDocumentIDRow
	for rows.Next() {
		var i GetSpecDomainsByDocumentIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.SortOrder,
			&i.ClassificationConfidence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecFeaturesByDomainIDs = `-- name: GetSpecFeaturesByDomainIDs :many
SELECT
    f.id,
    f.domain_id,
    f.name,
    f.description,
    f.sort_order
FROM spec_features f
WHERE f.domain_id = ANY($1::uuid[])
ORDER BY f.domain_id, f.sort_order, f.name
`

type GetSpecFeaturesByDomainIDsRow struct {
	ID          pgtype.UUID `json:"id"`
	DomainID    pgtype.UUID `json:"domain_id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	SortOrder   int32       `json:"sort_order"`
}

func (q *Queries) GetSpecFeaturesByDomainIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]GetSpecFeaturesByDomainIDsRow, error) {
	rows, err := q.db.Query(ctx, getSpecFeaturesByDomainIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpecFeaturesByDomainIDsRow
	for rows.Next() {
		var i GetSpecFeaturesByDomainIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Description,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecGenerationStatus = `-- name: GetSpecGenerationStatus :one
SELECT
    rj.state,
    rj.created_at,
    rj.finalized_at,
    rj.errors
FROM river_job rj
WHERE rj.kind = 'specview:generate'
  AND rj.args->>'analysis_id' = $1
ORDER BY rj.created_at DESC
LIMIT 1
`

type GetSpecGenerationStatusRow struct {
	State       RiverJobState      `json:"state"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	FinalizedAt pgtype.Timestamptz `json:"finalized_at"`
	Errors      [][]byte           `json:"errors"`
}

// Returns latest generation status for an analysis (any language)
func (q *Queries) GetSpecGenerationStatus(ctx context.Context, args []byte) (GetSpecGenerationStatusRow, error) {
	row := q.db.QueryRow(ctx, getSpecGenerationStatus, args)
	var i GetSpecGenerationStatusRow
	err := row.Scan(
		&i.State,
		&i.CreatedAt,
		&i.FinalizedAt,
		&i.Errors,
	)
	return i, err
}

const getSpecGenerationStatusByLanguage = `-- name: GetSpecGenerationStatusByLanguage :one
SELECT
    rj.state,
    rj.created_at,
    rj.finalized_at,
    rj.errors
FROM river_job rj
WHERE rj.kind = 'specview:generate'
  AND rj.args->>'analysis_id' = $1
  AND rj.args->>'language' = $2
ORDER BY rj.created_at DESC
LIMIT 1
`

type GetSpecGenerationStatusByLanguageParams struct {
	AnalysisID []byte `json:"analysis_id"`
	Language   []byte `json:"language"`
}

type GetSpecGenerationStatusByLanguageRow struct {
	State       RiverJobState      `json:"state"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	FinalizedAt pgtype.Timestamptz `json:"finalized_at"`
	Errors      [][]byte           `json:"errors"`
}

// Returns generation status for a specific analysis + language combination
func (q *Queries) GetSpecGenerationStatusByLanguage(ctx context.Context, arg GetSpecGenerationStatusByLanguageParams) (GetSpecGenerationStatusByLanguageRow, error) {
	row := q.db.QueryRow(ctx, getSpecGenerationStatusByLanguage, arg.AnalysisID, arg.Language)
	var i GetSpecGenerationStatusByLanguageRow
	err := row.Scan(
		&i.State,
		&i.CreatedAt,
		&i.FinalizedAt,
		&i.Errors,
	)
	return i, err
}
