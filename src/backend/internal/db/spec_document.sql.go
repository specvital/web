// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: spec_document.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkAnalysisExists = `-- name: CheckAnalysisExists :one
SELECT EXISTS(
    SELECT 1 FROM analyses WHERE id = $1 AND status = 'completed'
) AS exists
`

func (q *Queries) CheckAnalysisExists(ctx context.Context, id pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkAnalysisExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkSpecDocumentExistsByLanguage = `-- name: CheckSpecDocumentExistsByLanguage :one
SELECT EXISTS(
    SELECT 1 FROM spec_documents WHERE analysis_id = $1 AND language = $2
) AS exists
`

type CheckSpecDocumentExistsByLanguageParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	Language   string      `json:"language"`
}

func (q *Queries) CheckSpecDocumentExistsByLanguage(ctx context.Context, arg CheckSpecDocumentExistsByLanguageParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkSpecDocumentExistsByLanguage, arg.AnalysisID, arg.Language)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getAvailableLanguagesByAnalysisID = `-- name: GetAvailableLanguagesByAnalysisID :many
SELECT
    sd.language,
    sd.version AS latest_version,
    sd.created_at
FROM spec_documents sd
WHERE sd.analysis_id = $1
  AND sd.version = (
      SELECT MAX(sd2.version)
      FROM spec_documents sd2
      WHERE sd2.analysis_id = sd.analysis_id
        AND sd2.language = sd.language
  )
ORDER BY sd.language
`

type GetAvailableLanguagesByAnalysisIDRow struct {
	Language      string             `json:"language"`
	LatestVersion int32              `json:"latest_version"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
}

// Returns all available languages for an analysis with their latest version info (legacy - no user filter)
func (q *Queries) GetAvailableLanguagesByAnalysisID(ctx context.Context, analysisID pgtype.UUID) ([]GetAvailableLanguagesByAnalysisIDRow, error) {
	rows, err := q.db.Query(ctx, getAvailableLanguagesByAnalysisID, analysisID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableLanguagesByAnalysisIDRow
	for rows.Next() {
		var i GetAvailableLanguagesByAnalysisIDRow
		if err := rows.Scan(&i.Language, &i.LatestVersion, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableLanguagesByUserAndAnalysis = `-- name: GetAvailableLanguagesByUserAndAnalysis :many
SELECT
    sd.language,
    sd.version AS latest_version,
    sd.created_at
FROM spec_documents sd
WHERE sd.analysis_id = $1
  AND sd.user_id = $2
  AND sd.version = (
      SELECT MAX(sd2.version)
      FROM spec_documents sd2
      WHERE sd2.analysis_id = sd.analysis_id
        AND sd2.user_id = sd.user_id
        AND sd2.language = sd.language
  )
ORDER BY sd.language
`

type GetAvailableLanguagesByUserAndAnalysisParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	UserID     pgtype.UUID `json:"user_id"`
}

type GetAvailableLanguagesByUserAndAnalysisRow struct {
	Language      string             `json:"language"`
	LatestVersion int32              `json:"latest_version"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
}

// Returns all available languages for a specific user and analysis with their latest version info
func (q *Queries) GetAvailableLanguagesByUserAndAnalysis(ctx context.Context, arg GetAvailableLanguagesByUserAndAnalysisParams) ([]GetAvailableLanguagesByUserAndAnalysisRow, error) {
	rows, err := q.db.Query(ctx, getAvailableLanguagesByUserAndAnalysis, arg.AnalysisID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableLanguagesByUserAndAnalysisRow
	for rows.Next() {
		var i GetAvailableLanguagesByUserAndAnalysisRow
		if err := rows.Scan(&i.Language, &i.LatestVersion, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecBehaviorSourceInfo = `-- name: GetSpecBehaviorSourceInfo :many
SELECT
    b.id AS behavior_id,
    tc.line_number,
    tc.status::text,
    tf.file_path,
    tf.framework
FROM spec_behaviors b
JOIN test_cases tc ON tc.id = b.source_test_case_id
JOIN test_suites ts ON ts.id = tc.suite_id
JOIN test_files tf ON tf.id = ts.file_id
WHERE b.id = ANY($1::uuid[])
`

type GetSpecBehaviorSourceInfoRow struct {
	BehaviorID pgtype.UUID `json:"behavior_id"`
	LineNumber pgtype.Int4 `json:"line_number"`
	TcStatus   string      `json:"tc_status"`
	FilePath   string      `json:"file_path"`
	Framework  pgtype.Text `json:"framework"`
}

func (q *Queries) GetSpecBehaviorSourceInfo(ctx context.Context, dollar_1 []pgtype.UUID) ([]GetSpecBehaviorSourceInfoRow, error) {
	rows, err := q.db.Query(ctx, getSpecBehaviorSourceInfo, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpecBehaviorSourceInfoRow
	for rows.Next() {
		var i GetSpecBehaviorSourceInfoRow
		if err := rows.Scan(
			&i.BehaviorID,
			&i.LineNumber,
			&i.TcStatus,
			&i.FilePath,
			&i.Framework,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecBehaviorsByFeatureIDs = `-- name: GetSpecBehaviorsByFeatureIDs :many
SELECT
    b.id,
    b.feature_id,
    b.original_name,
    b.converted_description,
    b.sort_order,
    b.source_test_case_id
FROM spec_behaviors b
WHERE b.feature_id = ANY($1::uuid[])
ORDER BY b.feature_id, b.sort_order
`

type GetSpecBehaviorsByFeatureIDsRow struct {
	ID                   pgtype.UUID `json:"id"`
	FeatureID            pgtype.UUID `json:"feature_id"`
	OriginalName         string      `json:"original_name"`
	ConvertedDescription string      `json:"converted_description"`
	SortOrder            int32       `json:"sort_order"`
	SourceTestCaseID     pgtype.UUID `json:"source_test_case_id"`
}

func (q *Queries) GetSpecBehaviorsByFeatureIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]GetSpecBehaviorsByFeatureIDsRow, error) {
	rows, err := q.db.Query(ctx, getSpecBehaviorsByFeatureIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpecBehaviorsByFeatureIDsRow
	for rows.Next() {
		var i GetSpecBehaviorsByFeatureIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.FeatureID,
			&i.OriginalName,
			&i.ConvertedDescription,
			&i.SortOrder,
			&i.SourceTestCaseID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecDocumentByAnalysisID = `-- name: GetSpecDocumentByAnalysisID :one
SELECT
    sd.id,
    sd.analysis_id,
    sd.user_id,
    sd.language,
    sd.version,
    sd.executive_summary,
    sd.model_id,
    sd.created_at
FROM spec_documents sd
WHERE sd.analysis_id = $1
ORDER BY sd.version DESC
LIMIT 1
`

type GetSpecDocumentByAnalysisIDRow struct {
	ID               pgtype.UUID        `json:"id"`
	AnalysisID       pgtype.UUID        `json:"analysis_id"`
	UserID           pgtype.UUID        `json:"user_id"`
	Language         string             `json:"language"`
	Version          int32              `json:"version"`
	ExecutiveSummary pgtype.Text        `json:"executive_summary"`
	ModelID          string             `json:"model_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

// (legacy - no user filter) Returns most recent spec document for an analysis
func (q *Queries) GetSpecDocumentByAnalysisID(ctx context.Context, analysisID pgtype.UUID) (GetSpecDocumentByAnalysisIDRow, error) {
	row := q.db.QueryRow(ctx, getSpecDocumentByAnalysisID, analysisID)
	var i GetSpecDocumentByAnalysisIDRow
	err := row.Scan(
		&i.ID,
		&i.AnalysisID,
		&i.UserID,
		&i.Language,
		&i.Version,
		&i.ExecutiveSummary,
		&i.ModelID,
		&i.CreatedAt,
	)
	return i, err
}

const getSpecDocumentByAnalysisIDAndLanguage = `-- name: GetSpecDocumentByAnalysisIDAndLanguage :one
SELECT
    sd.id,
    sd.analysis_id,
    sd.user_id,
    sd.language,
    sd.version,
    sd.executive_summary,
    sd.model_id,
    sd.created_at
FROM spec_documents sd
WHERE sd.analysis_id = $1 AND sd.language = $2
ORDER BY sd.version DESC
LIMIT 1
`

type GetSpecDocumentByAnalysisIDAndLanguageParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	Language   string      `json:"language"`
}

type GetSpecDocumentByAnalysisIDAndLanguageRow struct {
	ID               pgtype.UUID        `json:"id"`
	AnalysisID       pgtype.UUID        `json:"analysis_id"`
	UserID           pgtype.UUID        `json:"user_id"`
	Language         string             `json:"language"`
	Version          int32              `json:"version"`
	ExecutiveSummary pgtype.Text        `json:"executive_summary"`
	ModelID          string             `json:"model_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

// (legacy - no user filter) Returns most recent spec document for an analysis and language
func (q *Queries) GetSpecDocumentByAnalysisIDAndLanguage(ctx context.Context, arg GetSpecDocumentByAnalysisIDAndLanguageParams) (GetSpecDocumentByAnalysisIDAndLanguageRow, error) {
	row := q.db.QueryRow(ctx, getSpecDocumentByAnalysisIDAndLanguage, arg.AnalysisID, arg.Language)
	var i GetSpecDocumentByAnalysisIDAndLanguageRow
	err := row.Scan(
		&i.ID,
		&i.AnalysisID,
		&i.UserID,
		&i.Language,
		&i.Version,
		&i.ExecutiveSummary,
		&i.ModelID,
		&i.CreatedAt,
	)
	return i, err
}

const getSpecDocumentByUserAndAnalysis = `-- name: GetSpecDocumentByUserAndAnalysis :one
SELECT
    sd.id,
    sd.analysis_id,
    sd.user_id,
    sd.language,
    sd.version,
    sd.executive_summary,
    sd.model_id,
    sd.created_at
FROM spec_documents sd
WHERE sd.analysis_id = $1 AND sd.user_id = $2
ORDER BY sd.version DESC
LIMIT 1
`

type GetSpecDocumentByUserAndAnalysisParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	UserID     pgtype.UUID `json:"user_id"`
}

type GetSpecDocumentByUserAndAnalysisRow struct {
	ID               pgtype.UUID        `json:"id"`
	AnalysisID       pgtype.UUID        `json:"analysis_id"`
	UserID           pgtype.UUID        `json:"user_id"`
	Language         string             `json:"language"`
	Version          int32              `json:"version"`
	ExecutiveSummary pgtype.Text        `json:"executive_summary"`
	ModelID          string             `json:"model_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

// Returns spec document for a specific user and analysis (for access control)
func (q *Queries) GetSpecDocumentByUserAndAnalysis(ctx context.Context, arg GetSpecDocumentByUserAndAnalysisParams) (GetSpecDocumentByUserAndAnalysisRow, error) {
	row := q.db.QueryRow(ctx, getSpecDocumentByUserAndAnalysis, arg.AnalysisID, arg.UserID)
	var i GetSpecDocumentByUserAndAnalysisRow
	err := row.Scan(
		&i.ID,
		&i.AnalysisID,
		&i.UserID,
		&i.Language,
		&i.Version,
		&i.ExecutiveSummary,
		&i.ModelID,
		&i.CreatedAt,
	)
	return i, err
}

const getSpecDocumentByUserAndAnalysisAndLanguage = `-- name: GetSpecDocumentByUserAndAnalysisAndLanguage :one
SELECT
    sd.id,
    sd.analysis_id,
    sd.user_id,
    sd.language,
    sd.version,
    sd.executive_summary,
    sd.model_id,
    sd.created_at
FROM spec_documents sd
WHERE sd.analysis_id = $1 AND sd.user_id = $2 AND sd.language = $3
ORDER BY sd.version DESC
LIMIT 1
`

type GetSpecDocumentByUserAndAnalysisAndLanguageParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	UserID     pgtype.UUID `json:"user_id"`
	Language   string      `json:"language"`
}

type GetSpecDocumentByUserAndAnalysisAndLanguageRow struct {
	ID               pgtype.UUID        `json:"id"`
	AnalysisID       pgtype.UUID        `json:"analysis_id"`
	UserID           pgtype.UUID        `json:"user_id"`
	Language         string             `json:"language"`
	Version          int32              `json:"version"`
	ExecutiveSummary pgtype.Text        `json:"executive_summary"`
	ModelID          string             `json:"model_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

// Returns spec document for a specific user, analysis, and language (for access control)
func (q *Queries) GetSpecDocumentByUserAndAnalysisAndLanguage(ctx context.Context, arg GetSpecDocumentByUserAndAnalysisAndLanguageParams) (GetSpecDocumentByUserAndAnalysisAndLanguageRow, error) {
	row := q.db.QueryRow(ctx, getSpecDocumentByUserAndAnalysisAndLanguage, arg.AnalysisID, arg.UserID, arg.Language)
	var i GetSpecDocumentByUserAndAnalysisAndLanguageRow
	err := row.Scan(
		&i.ID,
		&i.AnalysisID,
		&i.UserID,
		&i.Language,
		&i.Version,
		&i.ExecutiveSummary,
		&i.ModelID,
		&i.CreatedAt,
	)
	return i, err
}

const getSpecDocumentByUserAndVersion = `-- name: GetSpecDocumentByUserAndVersion :one
SELECT
    sd.id,
    sd.analysis_id,
    sd.user_id,
    sd.language,
    sd.version,
    sd.executive_summary,
    sd.model_id,
    sd.created_at
FROM spec_documents sd
WHERE sd.analysis_id = $1 AND sd.user_id = $2 AND sd.language = $3 AND sd.version = $4
`

type GetSpecDocumentByUserAndVersionParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	UserID     pgtype.UUID `json:"user_id"`
	Language   string      `json:"language"`
	Version    int32       `json:"version"`
}

type GetSpecDocumentByUserAndVersionRow struct {
	ID               pgtype.UUID        `json:"id"`
	AnalysisID       pgtype.UUID        `json:"analysis_id"`
	UserID           pgtype.UUID        `json:"user_id"`
	Language         string             `json:"language"`
	Version          int32              `json:"version"`
	ExecutiveSummary pgtype.Text        `json:"executive_summary"`
	ModelID          string             `json:"model_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

// Returns a specific version of a spec document for a specific user
func (q *Queries) GetSpecDocumentByUserAndVersion(ctx context.Context, arg GetSpecDocumentByUserAndVersionParams) (GetSpecDocumentByUserAndVersionRow, error) {
	row := q.db.QueryRow(ctx, getSpecDocumentByUserAndVersion,
		arg.AnalysisID,
		arg.UserID,
		arg.Language,
		arg.Version,
	)
	var i GetSpecDocumentByUserAndVersionRow
	err := row.Scan(
		&i.ID,
		&i.AnalysisID,
		&i.UserID,
		&i.Language,
		&i.Version,
		&i.ExecutiveSummary,
		&i.ModelID,
		&i.CreatedAt,
	)
	return i, err
}

const getSpecDocumentByVersion = `-- name: GetSpecDocumentByVersion :one
SELECT
    sd.id,
    sd.analysis_id,
    sd.user_id,
    sd.language,
    sd.version,
    sd.executive_summary,
    sd.model_id,
    sd.created_at
FROM spec_documents sd
WHERE sd.analysis_id = $1 AND sd.language = $2 AND sd.version = $3
`

type GetSpecDocumentByVersionParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	Language   string      `json:"language"`
	Version    int32       `json:"version"`
}

type GetSpecDocumentByVersionRow struct {
	ID               pgtype.UUID        `json:"id"`
	AnalysisID       pgtype.UUID        `json:"analysis_id"`
	UserID           pgtype.UUID        `json:"user_id"`
	Language         string             `json:"language"`
	Version          int32              `json:"version"`
	ExecutiveSummary pgtype.Text        `json:"executive_summary"`
	ModelID          string             `json:"model_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

// Returns a specific version of a spec document (legacy - no user filter)
func (q *Queries) GetSpecDocumentByVersion(ctx context.Context, arg GetSpecDocumentByVersionParams) (GetSpecDocumentByVersionRow, error) {
	row := q.db.QueryRow(ctx, getSpecDocumentByVersion, arg.AnalysisID, arg.Language, arg.Version)
	var i GetSpecDocumentByVersionRow
	err := row.Scan(
		&i.ID,
		&i.AnalysisID,
		&i.UserID,
		&i.Language,
		&i.Version,
		&i.ExecutiveSummary,
		&i.ModelID,
		&i.CreatedAt,
	)
	return i, err
}

const getSpecDomainsByDocumentID = `-- name: GetSpecDomainsByDocumentID :many
SELECT
    d.id,
    d.name,
    d.description,
    d.sort_order,
    d.classification_confidence
FROM spec_domains d
WHERE d.document_id = $1
ORDER BY d.sort_order, d.name
`

type GetSpecDomainsByDocumentIDRow struct {
	ID                       pgtype.UUID    `json:"id"`
	Name                     string         `json:"name"`
	Description              pgtype.Text    `json:"description"`
	SortOrder                int32          `json:"sort_order"`
	ClassificationConfidence pgtype.Numeric `json:"classification_confidence"`
}

func (q *Queries) GetSpecDomainsByDocumentID(ctx context.Context, documentID pgtype.UUID) ([]GetSpecDomainsByDocumentIDRow, error) {
	rows, err := q.db.Query(ctx, getSpecDomainsByDocumentID, documentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpecDomainsByDocumentIDRow
	for rows.Next() {
		var i GetSpecDomainsByDocumentIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.SortOrder,
			&i.ClassificationConfidence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecFeaturesByDomainIDs = `-- name: GetSpecFeaturesByDomainIDs :many
SELECT
    f.id,
    f.domain_id,
    f.name,
    f.description,
    f.sort_order
FROM spec_features f
WHERE f.domain_id = ANY($1::uuid[])
ORDER BY f.domain_id, f.sort_order, f.name
`

type GetSpecFeaturesByDomainIDsRow struct {
	ID          pgtype.UUID `json:"id"`
	DomainID    pgtype.UUID `json:"domain_id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	SortOrder   int32       `json:"sort_order"`
}

func (q *Queries) GetSpecFeaturesByDomainIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]GetSpecFeaturesByDomainIDsRow, error) {
	rows, err := q.db.Query(ctx, getSpecFeaturesByDomainIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpecFeaturesByDomainIDsRow
	for rows.Next() {
		var i GetSpecFeaturesByDomainIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Description,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecGenerationStatus = `-- name: GetSpecGenerationStatus :one
SELECT
    rj.state,
    rj.created_at,
    rj.finalized_at,
    rj.errors
FROM river_job rj
WHERE rj.kind = 'specview:generate'
  AND rj.args->>'analysis_id' = $1
  AND rj.args->>'user_id' = $2
ORDER BY rj.created_at DESC
LIMIT 1
`

type GetSpecGenerationStatusParams struct {
	AnalysisID []byte `json:"analysis_id"`
	UserID     []byte `json:"user_id"`
}

type GetSpecGenerationStatusRow struct {
	State       RiverJobState      `json:"state"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	FinalizedAt pgtype.Timestamptz `json:"finalized_at"`
	Errors      [][]byte           `json:"errors"`
}

// Returns latest generation status for a specific user and analysis (any language)
func (q *Queries) GetSpecGenerationStatus(ctx context.Context, arg GetSpecGenerationStatusParams) (GetSpecGenerationStatusRow, error) {
	row := q.db.QueryRow(ctx, getSpecGenerationStatus, arg.AnalysisID, arg.UserID)
	var i GetSpecGenerationStatusRow
	err := row.Scan(
		&i.State,
		&i.CreatedAt,
		&i.FinalizedAt,
		&i.Errors,
	)
	return i, err
}

const getSpecGenerationStatusByLanguage = `-- name: GetSpecGenerationStatusByLanguage :one
SELECT
    rj.state,
    rj.created_at,
    rj.finalized_at,
    rj.errors
FROM river_job rj
WHERE rj.kind = 'specview:generate'
  AND rj.args->>'analysis_id' = $1
  AND rj.args->>'user_id' = $2
  AND rj.args->>'language' = $3
ORDER BY rj.created_at DESC
LIMIT 1
`

type GetSpecGenerationStatusByLanguageParams struct {
	AnalysisID []byte `json:"analysis_id"`
	UserID     []byte `json:"user_id"`
	Language   []byte `json:"language"`
}

type GetSpecGenerationStatusByLanguageRow struct {
	State       RiverJobState      `json:"state"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	FinalizedAt pgtype.Timestamptz `json:"finalized_at"`
	Errors      [][]byte           `json:"errors"`
}

// Returns generation status for a specific user, analysis, and language combination
func (q *Queries) GetSpecGenerationStatusByLanguage(ctx context.Context, arg GetSpecGenerationStatusByLanguageParams) (GetSpecGenerationStatusByLanguageRow, error) {
	row := q.db.QueryRow(ctx, getSpecGenerationStatusByLanguage, arg.AnalysisID, arg.UserID, arg.Language)
	var i GetSpecGenerationStatusByLanguageRow
	err := row.Scan(
		&i.State,
		&i.CreatedAt,
		&i.FinalizedAt,
		&i.Errors,
	)
	return i, err
}

const getVersionsByLanguage = `-- name: GetVersionsByLanguage :many
SELECT
    sd.version,
    sd.created_at,
    sd.model_id
FROM spec_documents sd
WHERE sd.analysis_id = $1 AND sd.language = $2
ORDER BY sd.version DESC
`

type GetVersionsByLanguageParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	Language   string      `json:"language"`
}

type GetVersionsByLanguageRow struct {
	Version   int32              `json:"version"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	ModelID   string             `json:"model_id"`
}

// Returns all versions for a specific analysis and language, ordered by version descending (legacy - no user filter)
func (q *Queries) GetVersionsByLanguage(ctx context.Context, arg GetVersionsByLanguageParams) ([]GetVersionsByLanguageRow, error) {
	rows, err := q.db.Query(ctx, getVersionsByLanguage, arg.AnalysisID, arg.Language)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVersionsByLanguageRow
	for rows.Next() {
		var i GetVersionsByLanguageRow
		if err := rows.Scan(&i.Version, &i.CreatedAt, &i.ModelID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVersionsByUserAndLanguage = `-- name: GetVersionsByUserAndLanguage :many
SELECT
    sd.version,
    sd.created_at,
    sd.model_id
FROM spec_documents sd
WHERE sd.analysis_id = $1 AND sd.user_id = $2 AND sd.language = $3
ORDER BY sd.version DESC
`

type GetVersionsByUserAndLanguageParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	UserID     pgtype.UUID `json:"user_id"`
	Language   string      `json:"language"`
}

type GetVersionsByUserAndLanguageRow struct {
	Version   int32              `json:"version"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	ModelID   string             `json:"model_id"`
}

// Returns all versions for a specific user, analysis and language, ordered by version descending
func (q *Queries) GetVersionsByUserAndLanguage(ctx context.Context, arg GetVersionsByUserAndLanguageParams) ([]GetVersionsByUserAndLanguageRow, error) {
	rows, err := q.db.Query(ctx, getVersionsByUserAndLanguage, arg.AnalysisID, arg.UserID, arg.Language)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVersionsByUserAndLanguageRow
	for rows.Next() {
		var i GetVersionsByUserAndLanguageRow
		if err := rows.Scan(&i.Version, &i.CreatedAt, &i.ModelID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
