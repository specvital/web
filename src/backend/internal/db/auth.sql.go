// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: auth.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRefreshToken = `-- name: CreateRefreshToken :one
INSERT INTO refresh_tokens (user_id, token_hash, family_id, expires_at, replaces)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, family_id, created_at
`

type CreateRefreshTokenParams struct {
	UserID    pgtype.UUID        `json:"user_id"`
	TokenHash string             `json:"token_hash"`
	FamilyID  pgtype.UUID        `json:"family_id"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	Replaces  pgtype.UUID        `json:"replaces"`
}

type CreateRefreshTokenRow struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	FamilyID  pgtype.UUID        `json:"family_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) (CreateRefreshTokenRow, error) {
	row := q.db.QueryRow(ctx, createRefreshToken,
		arg.UserID,
		arg.TokenHash,
		arg.FamilyID,
		arg.ExpiresAt,
		arg.Replaces,
	)
	var i CreateRefreshTokenRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FamilyID,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, username, avatar_url)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateUserParams struct {
	Email     pgtype.Text `json:"email"`
	Username  string      `json:"username"`
	AvatarUrl pgtype.Text `json:"avatar_url"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Email, arg.Username, arg.AvatarUrl)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteExpiredRefreshTokens = `-- name: DeleteExpiredRefreshTokens :exec
DELETE FROM refresh_tokens
WHERE expires_at < now() - INTERVAL '7 days'
`

func (q *Queries) DeleteExpiredRefreshTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredRefreshTokens)
	return err
}

const getOAuthAccountByProvider = `-- name: GetOAuthAccountByProvider :one
SELECT
    oa.id,
    oa.user_id,
    oa.provider,
    oa.provider_user_id,
    oa.provider_username,
    oa.access_token,
    oa.scope,
    oa.created_at,
    oa.updated_at
FROM oauth_accounts oa
WHERE oa.provider = $1 AND oa.provider_user_id = $2
`

type GetOAuthAccountByProviderParams struct {
	Provider       OauthProvider `json:"provider"`
	ProviderUserID string        `json:"provider_user_id"`
}

func (q *Queries) GetOAuthAccountByProvider(ctx context.Context, arg GetOAuthAccountByProviderParams) (OauthAccount, error) {
	row := q.db.QueryRow(ctx, getOAuthAccountByProvider, arg.Provider, arg.ProviderUserID)
	var i OauthAccount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.ProviderUserID,
		&i.ProviderUsername,
		&i.AccessToken,
		&i.Scope,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOAuthAccountByUserID = `-- name: GetOAuthAccountByUserID :one
SELECT
    oa.id,
    oa.user_id,
    oa.provider,
    oa.provider_user_id,
    oa.provider_username,
    oa.access_token,
    oa.scope,
    oa.created_at,
    oa.updated_at
FROM oauth_accounts oa
WHERE oa.user_id = $1 AND oa.provider = $2
`

type GetOAuthAccountByUserIDParams struct {
	UserID   pgtype.UUID   `json:"user_id"`
	Provider OauthProvider `json:"provider"`
}

func (q *Queries) GetOAuthAccountByUserID(ctx context.Context, arg GetOAuthAccountByUserIDParams) (OauthAccount, error) {
	row := q.db.QueryRow(ctx, getOAuthAccountByUserID, arg.UserID, arg.Provider)
	var i OauthAccount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.ProviderUserID,
		&i.ProviderUsername,
		&i.AccessToken,
		&i.Scope,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRefreshTokenByHash = `-- name: GetRefreshTokenByHash :one
SELECT
    id,
    user_id,
    token_hash,
    family_id,
    expires_at,
    created_at,
    revoked_at,
    replaces
FROM refresh_tokens
WHERE token_hash = $1
`

func (q *Queries) GetRefreshTokenByHash(ctx context.Context, tokenHash string) (RefreshToken, error) {
	row := q.db.QueryRow(ctx, getRefreshTokenByHash, tokenHash)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.FamilyID,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.RevokedAt,
		&i.Replaces,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT
    id,
    email,
    username,
    avatar_url,
    last_login_at,
    created_at,
    updated_at
FROM users
WHERE email = $1
`

type GetUserByEmailRow struct {
	ID          pgtype.UUID        `json:"id"`
	Email       pgtype.Text        `json:"email"`
	Username    string             `json:"username"`
	AvatarUrl   pgtype.Text        `json:"avatar_url"`
	LastLoginAt pgtype.Timestamptz `json:"last_login_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email pgtype.Text) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.AvatarUrl,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT
    id,
    email,
    username,
    avatar_url,
    last_login_at,
    created_at,
    updated_at
FROM users
WHERE id = $1
`

type GetUserByIDRow struct {
	ID          pgtype.UUID        `json:"id"`
	Email       pgtype.Text        `json:"email"`
	Username    string             `json:"username"`
	AvatarUrl   pgtype.Text        `json:"avatar_url"`
	LastLoginAt pgtype.Timestamptz `json:"last_login_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.AvatarUrl,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserTokenVersion = `-- name: GetUserTokenVersion :one
SELECT token_version FROM users WHERE id = $1
`

func (q *Queries) GetUserTokenVersion(ctx context.Context, id pgtype.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getUserTokenVersion, id)
	var token_version int32
	err := row.Scan(&token_version)
	return token_version, err
}

const incrementUserTokenVersion = `-- name: IncrementUserTokenVersion :execrows
UPDATE users
SET token_version = token_version + 1, updated_at = now()
WHERE id = $1
`

func (q *Queries) IncrementUserTokenVersion(ctx context.Context, id pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, incrementUserTokenVersion, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const revokeRefreshToken = `-- name: RevokeRefreshToken :execrows
UPDATE refresh_tokens
SET revoked_at = now()
WHERE id = $1 AND revoked_at IS NULL
`

func (q *Queries) RevokeRefreshToken(ctx context.Context, id pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, revokeRefreshToken, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const revokeRefreshTokenFamily = `-- name: RevokeRefreshTokenFamily :exec
UPDATE refresh_tokens
SET revoked_at = now()
WHERE family_id = $1 AND revoked_at IS NULL
`

func (q *Queries) RevokeRefreshTokenFamily(ctx context.Context, familyID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, revokeRefreshTokenFamily, familyID)
	return err
}

const revokeUserRefreshTokens = `-- name: RevokeUserRefreshTokens :exec
UPDATE refresh_tokens
SET revoked_at = now()
WHERE user_id = $1 AND revoked_at IS NULL
`

func (q *Queries) RevokeUserRefreshTokens(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, revokeUserRefreshTokens, userID)
	return err
}

const updateLastLogin = `-- name: UpdateLastLogin :exec
UPDATE users
SET last_login_at = now(), updated_at = now()
WHERE id = $1
`

func (q *Queries) UpdateLastLogin(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateLastLogin, id)
	return err
}

const upsertOAuthAccount = `-- name: UpsertOAuthAccount :one
INSERT INTO oauth_accounts (user_id, provider, provider_user_id, provider_username, access_token, scope)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (provider, provider_user_id) DO UPDATE SET
    provider_username = EXCLUDED.provider_username,
    access_token = EXCLUDED.access_token,
    scope = EXCLUDED.scope,
    updated_at = now()
RETURNING id
`

type UpsertOAuthAccountParams struct {
	UserID           pgtype.UUID   `json:"user_id"`
	Provider         OauthProvider `json:"provider"`
	ProviderUserID   string        `json:"provider_user_id"`
	ProviderUsername pgtype.Text   `json:"provider_username"`
	AccessToken      pgtype.Text   `json:"access_token"`
	Scope            pgtype.Text   `json:"scope"`
}

func (q *Queries) UpsertOAuthAccount(ctx context.Context, arg UpsertOAuthAccountParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, upsertOAuthAccount,
		arg.UserID,
		arg.Provider,
		arg.ProviderUserID,
		arg.ProviderUsername,
		arg.AccessToken,
		arg.Scope,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}
