// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: auth.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, username, avatar_url)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateUserParams struct {
	Email     pgtype.Text `json:"email"`
	Username  string      `json:"username"`
	AvatarUrl pgtype.Text `json:"avatar_url"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Email, arg.Username, arg.AvatarUrl)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getOAuthAccountByProvider = `-- name: GetOAuthAccountByProvider :one
SELECT
    oa.id,
    oa.user_id,
    oa.provider,
    oa.provider_user_id,
    oa.provider_username,
    oa.access_token,
    oa.scope,
    oa.created_at,
    oa.updated_at
FROM oauth_accounts oa
WHERE oa.provider = $1 AND oa.provider_user_id = $2
`

type GetOAuthAccountByProviderParams struct {
	Provider       OauthProvider `json:"provider"`
	ProviderUserID string        `json:"provider_user_id"`
}

func (q *Queries) GetOAuthAccountByProvider(ctx context.Context, arg GetOAuthAccountByProviderParams) (OauthAccount, error) {
	row := q.db.QueryRow(ctx, getOAuthAccountByProvider, arg.Provider, arg.ProviderUserID)
	var i OauthAccount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.ProviderUserID,
		&i.ProviderUsername,
		&i.AccessToken,
		&i.Scope,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOAuthAccountByUserID = `-- name: GetOAuthAccountByUserID :one
SELECT
    oa.id,
    oa.user_id,
    oa.provider,
    oa.provider_user_id,
    oa.provider_username,
    oa.access_token,
    oa.scope,
    oa.created_at,
    oa.updated_at
FROM oauth_accounts oa
WHERE oa.user_id = $1 AND oa.provider = $2
`

type GetOAuthAccountByUserIDParams struct {
	UserID   pgtype.UUID   `json:"user_id"`
	Provider OauthProvider `json:"provider"`
}

func (q *Queries) GetOAuthAccountByUserID(ctx context.Context, arg GetOAuthAccountByUserIDParams) (OauthAccount, error) {
	row := q.db.QueryRow(ctx, getOAuthAccountByUserID, arg.UserID, arg.Provider)
	var i OauthAccount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.ProviderUserID,
		&i.ProviderUsername,
		&i.AccessToken,
		&i.Scope,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT
    id,
    email,
    username,
    avatar_url,
    last_login_at,
    created_at,
    updated_at
FROM users
WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.AvatarUrl,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT
    id,
    email,
    username,
    avatar_url,
    last_login_at,
    created_at,
    updated_at
FROM users
WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.AvatarUrl,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLastLogin = `-- name: UpdateLastLogin :exec
UPDATE users
SET last_login_at = now(), updated_at = now()
WHERE id = $1
`

func (q *Queries) UpdateLastLogin(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateLastLogin, id)
	return err
}

const upsertOAuthAccount = `-- name: UpsertOAuthAccount :one
INSERT INTO oauth_accounts (user_id, provider, provider_user_id, provider_username, access_token, scope)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (provider, provider_user_id) DO UPDATE SET
    provider_username = EXCLUDED.provider_username,
    access_token = EXCLUDED.access_token,
    scope = EXCLUDED.scope,
    updated_at = now()
RETURNING id
`

type UpsertOAuthAccountParams struct {
	UserID           pgtype.UUID   `json:"user_id"`
	Provider         OauthProvider `json:"provider"`
	ProviderUserID   string        `json:"provider_user_id"`
	ProviderUsername pgtype.Text   `json:"provider_username"`
	AccessToken      pgtype.Text   `json:"access_token"`
	Scope            pgtype.Text   `json:"scope"`
}

func (q *Queries) UpsertOAuthAccount(ctx context.Context, arg UpsertOAuthAccountParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, upsertOAuthAccount,
		arg.UserID,
		arg.Provider,
		arg.ProviderUserID,
		arg.ProviderUsername,
		arg.AccessToken,
		arg.Scope,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}
