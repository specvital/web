// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: bookmark.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addBookmark = `-- name: AddBookmark :exec
INSERT INTO user_bookmarks (user_id, codebase_id)
VALUES ($1, $2)
ON CONFLICT (user_id, codebase_id) DO NOTHING
`

type AddBookmarkParams struct {
	UserID     pgtype.UUID `json:"user_id"`
	CodebaseID pgtype.UUID `json:"codebase_id"`
}

func (q *Queries) AddBookmark(ctx context.Context, arg AddBookmarkParams) error {
	_, err := q.db.Exec(ctx, addBookmark, arg.UserID, arg.CodebaseID)
	return err
}

const getBookmarkedCodebaseIDsByUserID = `-- name: GetBookmarkedCodebaseIDsByUserID :many
SELECT codebase_id
FROM user_bookmarks
WHERE user_id = $1
`

func (q *Queries) GetBookmarkedCodebaseIDsByUserID(ctx context.Context, userID pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getBookmarkedCodebaseIDsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var codebase_id pgtype.UUID
		if err := rows.Scan(&codebase_id); err != nil {
			return nil, err
		}
		items = append(items, codebase_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCodebaseByOwnerRepo = `-- name: GetCodebaseByOwnerRepo :one
SELECT id
FROM codebases
WHERE host = $1 AND owner = $2 AND name = $3 AND is_stale = false
`

type GetCodebaseByOwnerRepoParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

func (q *Queries) GetCodebaseByOwnerRepo(ctx context.Context, arg GetCodebaseByOwnerRepoParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getCodebaseByOwnerRepo, arg.Host, arg.Owner, arg.Name)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getUserBookmarks = `-- name: GetUserBookmarks :many
SELECT
    c.id AS codebase_id,
    c.owner,
    c.name,
    ub.created_at AS bookmarked_at,
    a.id AS analysis_id,
    a.commit_sha,
    a.completed_at AS analyzed_at,
    a.total_tests
FROM user_bookmarks ub
JOIN codebases c ON c.id = ub.codebase_id
LEFT JOIN LATERAL (
    SELECT id, commit_sha, completed_at, total_tests
    FROM analyses
    WHERE codebase_id = c.id AND status = 'completed'
    ORDER BY created_at DESC
    LIMIT 1
) a ON true
WHERE ub.user_id = $1 AND c.is_stale = false
ORDER BY ub.created_at DESC
`

type GetUserBookmarksRow struct {
	CodebaseID   pgtype.UUID        `json:"codebase_id"`
	Owner        string             `json:"owner"`
	Name         string             `json:"name"`
	BookmarkedAt pgtype.Timestamptz `json:"bookmarked_at"`
	AnalysisID   pgtype.UUID        `json:"analysis_id"`
	CommitSha    string             `json:"commit_sha"`
	AnalyzedAt   pgtype.Timestamptz `json:"analyzed_at"`
	TotalTests   int32              `json:"total_tests"`
}

func (q *Queries) GetUserBookmarks(ctx context.Context, userID pgtype.UUID) ([]GetUserBookmarksRow, error) {
	rows, err := q.db.Query(ctx, getUserBookmarks, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserBookmarksRow
	for rows.Next() {
		var i GetUserBookmarksRow
		if err := rows.Scan(
			&i.CodebaseID,
			&i.Owner,
			&i.Name,
			&i.BookmarkedAt,
			&i.AnalysisID,
			&i.CommitSha,
			&i.AnalyzedAt,
			&i.TotalTests,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isBookmarked = `-- name: IsBookmarked :one
SELECT EXISTS(
    SELECT 1 FROM user_bookmarks
    WHERE user_id = $1 AND codebase_id = $2
) AS is_bookmarked
`

type IsBookmarkedParams struct {
	UserID     pgtype.UUID `json:"user_id"`
	CodebaseID pgtype.UUID `json:"codebase_id"`
}

func (q *Queries) IsBookmarked(ctx context.Context, arg IsBookmarkedParams) (bool, error) {
	row := q.db.QueryRow(ctx, isBookmarked, arg.UserID, arg.CodebaseID)
	var is_bookmarked bool
	err := row.Scan(&is_bookmarked)
	return is_bookmarked, err
}

const removeBookmark = `-- name: RemoveBookmark :exec
DELETE FROM user_bookmarks
WHERE user_id = $1 AND codebase_id = $2
`

type RemoveBookmarkParams struct {
	UserID     pgtype.UUID `json:"user_id"`
	CodebaseID pgtype.UUID `json:"codebase_id"`
}

func (q *Queries) RemoveBookmark(ctx context.Context, arg RemoveBookmarkParams) error {
	_, err := q.db.Exec(ctx, removeBookmark, arg.UserID, arg.CodebaseID)
	return err
}
